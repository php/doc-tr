<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: e2f53f0f601cd3e97ebdb516e51de1825d0106ea Maintainer: nilgun Status: ready -->
<sect1 xml:id="language.types.type-juggling">
 <title>Tür Dönüşümü</title>

 <simpara>
  PHP değişken bildiriminde tür tanımlamayı gerektirmez. Bu durumda
  değişkenin türü saklanan değere göre saptanır. Yani,
  <type>string</type> türünde bir değer  <varname>$var</varname> değişkenine
  atanırsa <varname>$var</varname>, <type>string</type> türünde bir değişken
  haline gelir. <varname>$var</varname> değişkenine bir <type>int</type>
  değer atanırsa <varname>$var</varname>, <type>int</type> türünde bir
  değişken haline gelir.
 </simpara>

 <para>
  PHP belli bağlamlarda bir değerin türünü otomatik olarak dönüştürmeyi
  deneyebilir:
  <itemizedlist>
   <listitem>
    <simpara>Sayısal</simpara>
   </listitem>
   <listitem>
    <simpara>Dizgesel</simpara>
   </listitem>
   <listitem>
    <simpara>Mantıksal</simpara>
   </listitem>
   <listitem>
    <simpara>Tamsayılar ve dizge</simpara>
   </listitem>
   <listitem>
    <simpara>Karşılaştırmalı</simpara>
   </listitem>
   <listitem>
    <simpara>İşlevsel</simpara>
   </listitem>
  </itemizedlist>
 </para>

 <note>
  <simpara>
   Bir değerin farklı bir türde yorumlanması gerektiğinde değerin kendisinde
   tür değişikliği yapılmaz.
  </simpara>
 </note>

 <simpara>
  Bir değişkeni belli bir türde değerlendirilmeye zorlamak için bkz:
  <link linkend="language.types.typecasting">Tür Çarpıtma</link>. Bir
  değişkenin türünü değiştirmek için ise <function>settype</function>
  işlevinin açıklamasına bakılabilir.
 </simpara>

 <sect2>
  <title>Sayısal bağlamlar</title>
  <simpara>
   <link linkend="language.operators.arithmetic">Aritmetik işleçlerin</link>
   kullanıldığı bağlamlardır.
  </simpara>
  <simpara>
   Bu bağlamlarda, terimlerden biri <type>float</type> türündeyse her
   iki terim <type>float</type> olarak ele alınır ve sonuç <type>float</type>
   türünde olur. Aksi takdirde, terimler <type>int</type> olarak
   yorumlanır ve sonuç <type>int</type> türünde olur. PHP 8.0.0 ve sonrasında,
   terimlerden birinin yorumlanamaması <classname>TypeError</classname>
   istisnasına yol açabilir.
  </simpara>
 </sect2>

 <sect2>
  <title>Dizgesel bağlamlar</title>

  <simpara>
   <function>echo</function>, <function>print</function> işlevleri,
   <link linkend="language.types.string.parsing">dizge çözümlemesi</link>,
   veya
   <link linkend="language.operators.string">dizge birleştirme işleci</link>
   kullanılan bağlamlardır.
  </simpara>

  <simpara>
   Bu bağlamlarda değer <type>string</type> türünde değerlendirilir.
  </simpara>
 </sect2>

 <sect2>
  <title>Mantıksal bağlamlar</title>

  <simpara>
   <link linkend="language.operators.comparison.ternary">Üç terimli
   işleç</link> veya <link linkend="language.operators.logical">mantıksal
   işleçlerin</link> kullanıldığı koşullu deyimler içeren bağlamlardır.
  </simpara>

  <simpara>
   Bu bağlamlarda değer <type>bool</type> türünde değerlendirilir.
  </simpara>
 </sect2>

 <sect2>
  <title>Tamsayı ve dizge bağlamlar</title>

  <simpara>
   <link linkend="language.operators.bitwise">>Bitsel işleç</link> kullanılan
   bağlamlardır.
  </simpara>

  <simpara>
   Bu bağlamlarda tüm terimler <type>string</type> türündeyse sonuç da
   <type>string</type> türünde olur. Aksi takdirde, terimler <type>int</type>
   türünde yorumlanır ve sonuç da <type>int</type> türünde olur. PHP 8.0.0 ve
   sonrasında, terimlerden birinin yorumlanamaması
   <classname>TypeError</classname> istisnasına yol açabilir.
  </simpara>
 </sect2>

 <sect2>
  <title>Kaşılaştırmalı bağlamlar</title>

  <simpara>
   <link linkend="language.operators.comparison">Karşılaştıma işleçleri</link>
   kullanılan bağlamlardır.
  </simpara>

  <simpara>
   Bu bağlamlarda görülen tür dönüşümleri
   <link linkend="language.operators.comparison.types">Çeşitli Türlerin
   Karşılaştırılması</link> tablosunda açıklanmıştır.
  </simpara>
 </sect2>

 <sect2>
  <title>İşlevsel bağlamlar</title>

  <simpara>
   Bir değerin belli bir türdeki bir değiştirgeye veya özelliğe atandığı veya
   dönüş türü bildiren bir işlevden döndürüldüğü bağlamlardır.
  </simpara>
  <para>
   Bu bağlamlarda kodlama zorlayıcı olduğunda (öntanımlıdır) sadece sayıl
   türler başka bir sayıl türe dönüştürülebilir. Basit tür bildirimleri
   durumunda davranış şöyledir:
   <itemizedlist>
    <listitem>
     <simpara>
      <type>bool</type> türünde bildirim: değer <type>bool</type> türünde
      değerlendirilir.
     </simpara>
     <simpara>
      <type>int</type> türünde bildirim: dönüşüm olması gerektiği gibi ise
      değer <type>int</type> türünde değerlendirilir. Örnek:
      <link linkend="language.types.numeric-strings">Sayısal dizgeler</link>.
     </simpara>
     <simpara>
      <type>float</type> türünde bildirim: dönüşüm olması gerektiği gibi ise
      değer <type>float</type> türünde değerlendirilir. Örnek:
      <link linkend="language.types.numeric-strings">Sayısal dizgeler</link>.
     </simpara>
     <simpara>
      <type>string</type> türünde bildirim: değer <type>string</type> türünde
      değerlendirilir.
     </simpara>
    </listitem>
   </itemizedlist>

   Tür bir birleşim ise
   <link linkend="language.types.declarations.union.coercive">Birleşim
   türleriyle zorlayıcı kodlama</link> bölümüne bakılabilir.
  </para>

  <warning>
   <simpara>
    <link linkend="functions.internal">Yerleşik işlevler</link> otomatik
    olarak &null; değerleri sayıl türlere zorlar. Bu davranışın PHP 8.1.0 ve
    sonrasında kullanımdan kalkması beklenmektedir.
   </simpara>
  </warning>
 </sect2>

 <sect2 xml:id="language.types.typecasting">
  <title>Tür Çarpıtma</title>

  <para>
   İstenen türün ismi yaylı ayraçlar arasında türü çarpıtılacak değişkenin
   önüne yazılır.
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$foo = 10;            // $foo bir tamsayıdır
$bar = (bool) $foo;   // $bar mantıksal türdedir
?>
]]>
   </programlisting>
  </informalexample>

  <simpara>
   İzin verilen çarpıtmalar:
  </simpara>

  <simplelist>
   <member><literal>(int)</literal> - <type>int</type> türüne dönüşüm</member>
   <member><literal>(bool)</literal> - <type>bool</type> türüne dönüşüm</member>
   <member><literal>(float)</literal> - <type>float</type> türüne dönüşüm</member>
   <member><literal>(string)</literal> - <type>string</type> türüne dönüşüm</member>
   <member><literal>(array)</literal> - <type>array</type> türüne dönüşüm</member>
   <member>><literal>(object)</literal> - <type>object</type> türüne dönüşüm</member>
   <member><literal>(unset)</literal> - <type>NULL</type>'a dönüşüm</member>
  </simplelist>
  <note>
   <para>
    <literal>(integer)</literal> çarpıtması <literal>(int)</literal> için
    takma addır. <literal>(boolean)</literal> çarpıtması
    <literal>(bool)</literal> için takma addır. <literal>(binary)</literal>
    çarpıtması <literal>(string)</literal> için takma addır.
    <literal>(double)</literal> ve <literal>(real)</literal> çarpıtması
    <literal>(float)</literal> için takma addır. Meşru tür isimleri
    kullanılmayan bu tür çarpıtmalarının kullanımı önerilmemektedir.
   </para>
  </note>
  <warning>
   <simpara>
    PHP 8.0.0 ve sonrasında <literal>(real)</literal> dönüşüm takma adının
    kullanımı önerilmemektedir.
   </simpara>
  </warning>

  <warning>
   <simpara>
    <literal>(unset)</literal> çarpıtması PHP 7.2.0 ve sonrasında
    önerilmemektedir. <literal>(unset)</literal> çarpıtması değişken veya
    çağrıya <type>NULL</type> değer atanmasıyla aynıdır.
    <literal>(unset)</literal> çarpıtması PHP 8.0.0 sürümünde kaldırılmıştır.
   </simpara>
  </warning>

  <caution>
   <simpara>
    <literal>(binary)</literal> çarpıtması ve <literal>b</literal> öneki
    ileriye dönük desteklenmektedir. Halen <literal>(binary)</literal>
    çarpıtması <literal>(string)</literal> ile aynı olsa da buna
    güvenilmemelidir.
   </simpara>
  </caution>

  <note>
   <para>
    Çarpıtmada yaylı ayraçların içinde sekmelere ve boşluklara izin
    verildiğinden aşağıdaki iki deyim eşdeğerdir:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$foo = (int) $bar;
$foo = ( int ) $bar;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </note>

  <informalexample>
   <simpara>
    Normal dizgelerin ikil dizgelere dönüştürülmesi:
   </simpara>

   <programlisting role="php">
<![CDATA[
<?php
$binary = (binary) $string;
$binary = b"ikil dizge";
?>
]]>
   </programlisting>
  </informalexample>

  <note>
   <simpara>
    Bir değişkenin türünü <type>string</type> türüne çarpıtmak yerine
    değişkeni çift tırnak içine almak aynı sonucu sağlar:
   </simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$foo = 10;            // $foo integer türündedir
$str = "$foo";        // $str string türündedir
$fst = (string) $foo; // $fst de string türündedir

// "bunlar aynı" basar
if ($fst === $str) {
    echo "bunlar aynı";
}
?>
]]>
    </programlisting>
   </informalexample>
  </note>

  <para>
   Belli türler arasında çarpıtma yapılırken tam olarak ne olup bittiği
   açıkça belli olmayabilir. Daha fazla bilgi için şu bölümlere bakınız:
  </para>

  <simplelist>
   <member>
    <link linkend="language.types.boolean.casting"><code>bool</code>
    türüne dönüşüm</link>
   </member>
   <member>
    <link linkend="language.types.integer.casting"><code>integer</code>
    türüne dönüşüm</link>
   </member>
   <member>
    <link linkend="language.types.float.casting"><code>float</code> türüne
    dönüşüm</link>
   </member>
   <member>
    <link linkend="language.types.string.casting"><code>string</code> türüne
    dönüşüm</link>
   </member>
   <member>
    <link linkend="language.types.array.casting"><code>array</code> türüne
    dönüşüm</link>
   </member>
   <member>
    <link linkend="language.types.object.casting"><code>object</code> türüne
    dönüşüm</link>
   </member>
   <member>
    <link linkend="language.types.resource.casting"><code>resource</code>
    türüne dönüşüm</link>
   </member>
   <member>
    <link linkend="language.types.null.casting"><code>NULL</code>'a
    dönüşüm</link>
   </member>
   <member>
    <link linkend="types.comparisons">Tür karşılaştırma tabloları</link>
   </member>
  </simplelist>
 </sect2>

 <simplesect>
  <note>
   <simpara>
    PHP dizgelerde dizge içi konumlar üzerinden dizilerdeki gibi indislemeyi
    desteklemektedir. Aşağıdaki örnekler tüm PHP sürümlerinde çalışır:
   </simpara>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$a    = 'car'; // $a bir dizgedir
$a[0] = 'b';   // $a hala bir dizgedir
echo $a;       // bar
?>
]]>
    </programlisting>
   </informalexample>

   <simpara>
    Daha ayrıntılı bilgi için bkz:
    <link linkend="language.types.string.substr">Karakter Karakter
    Dizgeye Erişim</link>.
   </simpara>
  </note>
 </simplesect>

</sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
