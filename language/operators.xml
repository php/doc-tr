<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: c36ce0b514faa2efce1427ae87ba9ea25cc038ad Maintainer: nilgun Status: ready -->
 <chapter xml:id="language.operators" xmlns="http://docbook.org/ns/docbook">
  <title>İşleçler</title>
  <simpara>
   Bir işleç, başka bir değer üretmek üzere bir veya daha fazla değer
   (programcı dilinde ifade) alan bir şeydir (yani, bu yapı bir ifade haline
   gelir).
  </simpara>
  <para>
   İşleçler aldıkları değer sayısına göre gruplanabilir. Tek terimli işleçler
   yalnızca bir değer alır, örneğin, <literal>!</literal> (<link
   linkend="language.operators.logical">mantıksal değil işleci</link>) veya
   <literal>++</literal> (<link linkend="language.operators.increment">arttırım
   işleci</link>). İki terimli işleçler iki değer alır, PHP'nin desteklediği
   işleçlerin çoğunluğu bu grupta olup <link
   linkend="language.operators.arithmetic">aritmetik işleçler</link>
   <literal>+</literal> (artı) ve <literal>-</literal> (eksi) örnek olarak
   verilebilir. Son olarak tek bir <link
   linkend="language.operators.comparison.ternary">üç terimli işleci</link>,
   <literal>? :</literal> vardır ve üç terim alır. Koşul işleci olarak da bilinir.
  </para>
  <para>
   PHP işleçleri tam liste halinde, aşağıda <link
   linkend="language.operators.precedence">İşleç Önceliği</link> bölümünde
   bulunabilir. Bölüm ayrıca, çeşitli farklı işleçleri içeren ifadelerin
   değerlendirilişini yöneten işleç önceliğini ve ilişkilendirmeyi de
   açıklamaktadır.
  </para>

  <sect1 xml:id="language.operators.precedence">
   <title>İşleç Önceliği</title>
   <para>
    İşleç önceliği iki ifadenin birbirine hangi sıkılıkta bağlı olduğunu
    belirtir. Örneğin, <literal>1 + 5 * 3</literal> ifadesinin sonucu 18 değil,
    16'dır. Çünkü, çarpma ("*") işlecinin önceliği toplama ("+") işlecinden
    yüksektir. Önceliği arttırmak için gerekirse parantezler kullanılabilir.
    Örneğin, <literal>(1 + 5) * 3</literal> ifadesinin sonucu 18 olacaktır.
   </para>
   <para>
    İşleçler eşit önceliğe sahip olduklarında aralarındaki ilişkiye işleçlerin
    gruplanışına göre karar verilir. Örneğin "-" isoldan ilişkilendirmelidir,
    dolayısıyla, <literal>1 - 2 - 3</literal> ifadesi
    <literal>(1 - 2) - 3</literal> olarak gruplanır ve <literal>-4</literal>
    olarak değerlendirlir. "=" ise sağdan ilişkilendirmelidir, dolayısıyla,
    <literal>$a = $b = $c</literal> ifadesi <literal>$a = ($b = $c)</literal>
    olarak gruplanır.  Özetle, soldan ilişkilendirme, ifadenin soldan sağa, sağdan
    ilişkilendirme ise sağdan sola değerlendirileceği anlamına gelir.
   </para>
   <para>
    İlişkisel olmayan eş öncelikli işleçler birbirlerinin ardından
    kullanılamazlar, örneğin <literal>1 &lt; 2 &gt; 1</literal> ifadesi PHP için
    uygun değilken <literal>1 &lt;= 1 == 1</literal> ifadesi uygundur. Sebebi
    <literal>==</literal> işlecinin <literal>&lt;=</literal> işlecinden daha az
    öncelikli olmasıdır.
   </para>
   <para>
    İlişkisellik sadece iki terimli (ve üç terimli) işleçler için anlamlıdır.
    Tek terimli işleçlerin önüne veya ardına ekleme yapıldığından bu fikir tek
    terimlilere uygulanabilir değildir. Örneğin, <literal>!!$a</literal>
    ifadesi sadece <literal>!(!$a)</literal> olarak gruplanabilir.
   </para>
   <para>
    Parantez kullanımı gerekli olmasa bile çoğunlukla kodun okunabilirliğini
    arttırır. Örtük işleç önceliğine ve ilişkiselliğine güvenmektense kodu
    açıkça gruplamak daha iyidir.
   </para>
   <para>
    Aşağıdaki listede işleçler en yüksek öncelikliden başlayıp en düşük
    öncelikliye doğru sıralanmışlardır. Aynı satırda yer alan işleçler
    eş öncelikli olup hangi sırada ele alınacaklarına değerlendirme sırasında
    karar verilir.
    <table>
     <title>İşleç Öncelikleri</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>İlişkilendirme</entry>
        <entry>İşleçler</entry>
        <entry>Ek bilgi</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>(yok)</entry>
        <entry>
         <literal>clone</literal>
         <literal>new</literal>
       </entry>
        <entry><link linkend="language.oop5.cloning">clone</link> ve <link
        linkend="language.oop5.basic.new">new</link></entry>
       </row>
       <row>
        <entry>(yok)</entry>
        <entry><literal>**</literal></entry>
        <entry>
         <link linkend="language.operators.arithmetic">aritmetik</link>
        </entry>
       </row>
       <row>
        <entry>sağdan</entry>
        <entry>
         <literal>+</literal>
         <literal>-</literal>
         <literal>++</literal>
         <literal>--</literal>
         <literal>~</literal>
         <literal>(int)</literal>
         <literal>(float)</literal>
         <literal>(string)</literal>
         <literal>(array)</literal>
         <literal>(object)</literal>
         <literal>(bool)</literal>
         <literal>@</literal>
        </entry>
        <entry>
         <link linkend="language.operators.arithmetic">aritmetik</link>
         (tek terimli <literal>+</literal> ve <literal>-</literal>),
         <link linkend="language.operators.increment">arttırım/eksiltim</link>,
         <link linkend="language.operators.bitwise">bitsel</link>,
         <link linkend="language.types.typecasting">tür
          çarpıtma</link>&listendand;
         <link linkend="language.operators.errorcontrol">hata denetimi</link>
        </entry>
       </row>
       <row>
        <entry>soldan</entry>
        <entry><literal>instanceof</literal></entry>
        <entry>
         <link linkend="language.operators.type">Tür</link>
        </entry>
       </row>
       <row>
        <entry>(yok)</entry>
        <entry><literal>!</literal></entry>
        <entry>
         <link linkend="language.operators.logical">mantıksal</link>
        </entry>
       </row>
       <row>
        <entry>soldan</entry>
        <entry>
         <literal>*</literal>
         <literal>/</literal>
         <literal>%</literal>
        </entry>
        <entry>
         <link linkend="language.operators.arithmetic">aritmetik</link>
        </entry>
       </row>
       <row>
        <entry>soldan</entry>
        <entry>
         <literal>+</literal>
         <literal>-</literal>
         <literal>.</literal>
        </entry>
        <entry>
         <link linkend="language.operators.arithmetic">aritmetik</link>
         (iki terimli <literal>+</literal> ve <literal>-</literal>),
         <link linkend="language.operators.array">dizi</link>&listendand;
         <link linkend="language.operators.string">dize</link> (PHP 8.0.0
         öncesinde <literal>.</literal>)
        </entry>
       </row>
       <row>
        <entry>soldan</entry>
        <entry>
         <literal>&lt;&lt;</literal>
         <literal>&gt;&gt;</literal>
        </entry>
        <entry>
         <link linkend="language.operators.bitwise">bitsel</link>
        </entry>
       </row>
       <row>
        <entry>soldan</entry>
        <entry><literal>.</literal></entry>
        <entry>
         <link linkend="language.operators.string">dize</link> (PHP 8.0.0
         öncesinde <literal>.</literal>)
        </entry>
       </row>
       <row>
        <entry>yönsüz</entry>
        <entry>
         <literal>&lt;</literal>
         <literal>&lt;=</literal>
         <literal>&gt;</literal>
         <literal>&gt;=</literal>
        </entry>
        <entry>
         <link linkend="language.operators.comparison">karşılaştırma</link>
        </entry>
       </row>
       <row>
        <entry>yönsüz</entry>
        <entry>
         <literal>==</literal>
         <literal>!=</literal>
         <literal>===</literal>
         <literal>!==</literal>
         <literal>&lt;&gt;</literal>
         <literal>&lt;=&gt;</literal>
        </entry>
        <entry>
         <link linkend="language.operators.comparison">karşılaştırma</link>
        </entry>
       </row>
       <row>
        <entry>left</entry>
        <entry><literal>&amp;</literal></entry>
        <entry>
         <link linkend="language.operators.bitwise">bitsel</link>&listendand;
         <link linkend="language.references">gönderimler</link></entry>
       </row>
       <row>
        <entry>soldan</entry>
        <entry><literal>^</literal></entry>
        <entry>
         <link linkend="language.operators.bitwise">bitsel</link>
        </entry>
       </row>
       <row>
        <entry>soldan</entry>
        <entry><literal>|</literal></entry>
        <entry>
         <link linkend="language.operators.bitwise">bitsel</link>
        </entry>
       </row>
       <row>
        <entry>soldan</entry>
        <entry><literal>&amp;&amp;</literal></entry>
        <entry>
         <link linkend="language.operators.logical">mantıksal</link>
        </entry>
       </row>
       <row>
        <entry>soldan</entry>
        <entry><literal>||</literal></entry>
        <entry>
         <link linkend="language.operators.logical">mantıksal</link>
        </entry>
       </row>
       <row>
        <entry>right</entry>
        <entry><literal>??</literal></entry>
        <entry>
         <link linkend="language.operators.comparison.coalesce">null birleşimi</link>
        </entry>
       </row>
       <row>
        <entry>yönsüz</entry>
        <entry><literal>? :</literal></entry>
        <entry>
         <link linkend="language.operators.comparison.ternary">üç terimli
         </link> (PHP 8.0.0 öncesinde soldan)
        </entry>
       </row>
       <row>
        <entry>sağdan</entry>
        <entry>
         <literal>=</literal>
         <literal>+=</literal>
         <literal>-=</literal>
         <literal>*=</literal>
         <literal>**=</literal>
         <literal>/=</literal>
         <literal>.=</literal>
         <literal>%=</literal>
         <literal>&amp;=</literal>
         <literal>|=</literal>
         <literal>^=</literal>
         <literal>&lt;&lt;=</literal>
         <literal>&gt;&gt;=</literal>
         <literal>??=</literal>
        </entry>
        <entry>
         <link linkend="language.operators.assignment">atama</link>
        </entry>
       </row>
        <row>
        <entry>(yok)</entry>
        <entry><literal>yield from</literal></entry>
        <entry>
         <link linkend="control-structures.yield.from">yield from</link>
        </entry>
       </row>
       <row>
        <entry>(yok)</entry>
        <entry><literal>yield</literal></entry>
        <entry>
         <link linkend="control-structures.yield">yield</link>
        </entry>
       </row>
       <row>
        <entry>(yok)</entry>
        <entry><literal>print</literal></entry>
        <entry><function>print</function></entry>
       </row>
       <row>
        <entry>soldan</entry>
        <entry><literal>and</literal></entry>
        <entry>
         <link linkend="language.operators.logical">mantıksal</link>
        </entry>
       </row>
       <row>
        <entry>soldan</entry>
        <entry><literal>xor</literal></entry>
        <entry>
         <link linkend="language.operators.logical">mantıksal</link>
        </entry>
       </row>
       <row>
        <entry>soldan</entry>
        <entry><literal>or</literal></entry>
        <entry>
         <link linkend="language.operators.logical">mantıksal</link>
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>
   <para>
    <example>
     <title>- Öncelik yönü</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 3 * 3 % 5; // (3 * 3) % 5 = 4
// üç terimli işlecin değerlendirilmesi C/C++ dillerinden farklıdır
$a = true ? 0 : true ? 1 : 2; // (true ? 0 : true) ? 1 : 2 = 2 (PHP 8.0.0 öncesi)

$a = 1;
$b = 2;
$a = $b += 3; // $a = ($b += 3) -> $a = 5, $b = 5
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    İşleç önceliklerini ve işlem yönünü ifadeni gruplanışı belirler. PHP
    (genelde) ifadenin hangi sırayla değerlendirileceğini belirmez ve
    kodlamada özel bir değerlendirme sırası kabulünden kaçınılmalıdır.
    Çünkü davranış PHP'nin sürümleri arasında farklı olabildiği gibi
    sarmalayan koda bağlı olarak da değişebilir.
    <example>
     <title>- Tanımsız değerlendirme sırası</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 1;
echo $a + $a++; // 2 veya 3 basabilir

$i = 1;
$array[$i] = $i++; // indis 1 veya 2 olabilir
?>
]]>
     </programlisting>
    </example>
    <example>
     <title><literal>+</literal>, <literal>-</literal> ve <literal>.</literal>
      aynı önceliğe sahiptir (PHP 8.0.0 öncesi)</title>
     <programlisting role="php">
<![CDATA[
<?php
$x = 4;
// bu satır beklenmedik bir çıktı ile sonuçlanabilir:
echo "x eksi bir eşittir " . $x-1 . ", ya da ben öyle umdum\n";

// çünkü aşağıdaki satır gibi değerlendirilir:
echo (("x eksi bir eşittir " . $x) - 1) . ", ya da ben öyle umdum\n";

// istenen öncelik parantez kullanarak elde edilebilir:
echo "x eksi bir eşittir " . ($x-1) . ", ya da ben öyle umdum\n";
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
-1, ya da ben öyle umdum
-1, ya da ben öyle umdum
x eksi bir eşittir 3, ya da ben öyle umdum
]]>
     </screen>
    </example>
   </para>
   <note>
    <para>
     Eşitlik (<literal>=</literal>) işleci çoğu işleçten daha düşük önceliğe
     sahip olduğundan PHP halen şuna benzer ifadelere izin vermektedir:
     <literal>foo()</literal> işlevinin dönüş değerini <varname>$a</varname>
     değişkenine atayan <literal>if (!$a = foo())</literal> ifadesi.
    </para>
   </note>
   <sect2 role="changelog">
    &reftitle.changelog;
    <informaltable>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>&Version;</entry>
        <entry>&Description;</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>8.0.0</entry>
        <entry>
         Dizelerin ard arda eklenmesi (<literal>.</literal>) artık aritmetik
         toplama ve çıkarma (<literal>+</literal> ve <literal>-</literal>) ve
         bitsel sola/sağa kaydırma (<literal>&lt;&lt;</literal> ve
         <literal>&gt;&gt;</literal>) işleçlerinden daha düşük öncelikli oldu;
         evvelce <literal>+</literal> ve <literal>-</literal> ile aynı
         önceliğe, <literal>&lt;&lt;</literal> ve <literal>&gt;&gt;</literal>
         işleçlerinden daha yüksek önceliğe sahipti.
        </entry>
       </row>
       <row>
        <entry>8.0.0</entry>
        <entry>
         Üç terimli işleç (<literal>? :</literal>) artık ilişkisel değil;
         evvelce soldan ilişkili idi.
        </entry>
       </row>
       <row>
        <entry>7.4.0</entry>
        <entry>
         Dizelerin ard arda eklenmesinin (<literal>.</literal>)
         toplama ve çıkarma (<literal>+</literal> ve <literal>-</literal>) ve
         bitsel sola/sağa kaydırma (<literal>&lt;&lt;</literal> ve
         <literal>&gt;&gt;</literal>) işleçlerine göre önceliğine (yani
         parantezsiz birlikte kullanımlarına) güvenilmesi artık önerilmiyor.
        </entry>
       </row>
       <row>
        <entry>7.4.0</entry>
        <entry>
         Üç terimli işlecin (<literal>? :</literal>) soldan ilişkiselliğine
         güvenmek artık önerilmiyor; yani, çok sayıda parantezsiz üç terimli
         artık iç içe yazılmamalıdır.
        </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.arithmetic">
   <title>Aritmetik İşleçler</title>
   <simpara>
    Okulda öğrendiğiniz temel aritmetiği hatırlıyor musunuz? Bu işleçler tam
    da öyle çalışır.
   </simpara>
   <table>
    <title>Aritmetik İşleçler</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Örnek</entry>
       <entry>İsim</entry>
       <entry>Sonuç</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>+$a</entry>
       <entry>Özdeşlik</entry>
       <entry>
        <varname>$a</varname>'nın <type>int</type> veya
        <type>float</type>'a dönüşümü.
       </entry>
      </row>
      <row>
       <entry><userinput>-$a</userinput></entry>
       <entry>Olumsuzlama</entry>
       <entry><varname>$a</varname>'nın eksi işaretlisi.</entry>
      </row>
      <row>
       <entry><userinput>$a + $b</userinput></entry>
       <entry>Toplama</entry>
       <entry><varname>$a</varname> ile <varname>$b</varname>'nin toplamı.</entry>
      </row>
      <row>
       <entry><userinput>$a - $b</userinput></entry>
       <entry>Çıkarma</entry>
       <entry><varname>$a</varname>'nın <varname>$b</varname>'den farkı.</entry>
      </row>
      <row>
       <entry><userinput>$a * $b</userinput></entry>
       <entry>Çarpma</entry>
       <entry><varname>$a</varname> ile <varname>$b</varname>'nin çarpımı.</entry>
      </row>
      <row>
       <entry><userinput>$a / $b</userinput></entry>
       <entry>Bölme</entry>
       <entry><varname>$a</varname>'nın <varname>$b</varname>'ye bölümü.</entry>
      </row>
      <row>
       <entry><userinput>$a % $b</userinput></entry>
       <entry>Kalan</entry>
       <entry><varname>$a</varname>'nın <varname>$b</varname>'ye bölümünden kalan.</entry>
      </row>
      <row>
       <entry>$a ** $b</entry>
       <entry>Üs</entry>
       <entry><varname>$a</varname> üssü <varname>$b</varname>.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
    Bölme işlecinin tamsayı bölüm vermesi için iki teriminin de tamsayı
    (veya dönüşüm sonucu tamsayı olan dizge) olması ve birbirlerine tam
    olarak bölünmesi gerekir, aksi takdirde bölüm gerçek sayı olacaktır.
    Tamsayı bölme için <function>intdiv</function> işlevine bakınız.
   </simpara>
   <simpara>
    Kalan işlecinin (<literal>%</literal>) terimleri gerçek sayılarsa
    tamsayıya (<type>int</type> türüne) dönüştürülürler. Gerçek sayı bölmeden
    kalan için <function>fmod</function> işlevine bakınız.
   </simpara>
   <para>
    <literal>%</literal> kalan işlecinin sonucu bölünenin işaretini alır. Yani
    <literal>$a % $b</literal> işlemini sonucu <varname>$a</varname> ile aynı
    işaretli olacaktır. Örnek:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

echo (5 % 3)."\n";           //  2 basar
echo (5 % -3)."\n";          //  2 basar
echo (-5 % 3)."\n";          // -2 basar
echo (-5 % -3)."\n";         // -2 basar

?>
]]>
     </programlisting>
    </informalexample>
   </para>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><link linkend="ref.math">Matematik işlevleri</link></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.assignment">
   <title>Atama İşleçleri</title>
   <simpara>
    Temel atama işleci "<literal>=</literal>" imidir. Programlamaya yeni
    başlayanlar bu işleci"eşittir" diye okurlar. Aslında yapılan işlem bir
    şeyleri birbirlerine eşitlemek değildir. Yaptığı iş sağındaki ifadenin
    değerini solundaki terimin değeri haline getirmektir, yani imleci içeren
    ifadeyi birşey'in değeri diye okumak daha doğrudur.
   </simpara>
   <para>
    Bir atama ifadesinin değeri atanan değerdir. Yani, "<literal>$a =
    3</literal>" ifadesinin değeri 3'tür. Bunun bir takım yan sonuçları da
    vardır:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

$a = ($b = 4) + 5; // $a'nın değeri 9, $b'nin değeri 4 olur.

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Temel atama işlecinden başka atama işlemini temel aritmetik, <link
    linkend="language.operators">ikil aritmetik</link> işlemleriyle veya
    dizi ya da dizge birleştirme işlemleriyle  birleştiren, "birleşik atama
    işleçleri" vardır. Örnek:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php

$a = 3;
$a += 5; // $a'nın değeri 8 olur, asıl işlem: $a = $a + 5;
$b = "Herkese ";
$b .= "Merhaba!"; // $b'nin değeri "Herkese Merhaba!" olur.
                  // asıl işlem: $b = $b . "Merhaba!";

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Atama işleminin özgün değişkeni yeni değişkene kopyaladığına (değeriyle
    atadığına) dikkat ediniz. Dolayısıyla birinde yapılan değişiklik
    diğerini etkilemeyecektir. Kapalı bir döngü içinde büyükçe bir diziye
    atama işlemleri yapma ihtiyacı duyarsanız bu ayrı bir anlam kazanır.
    </para>
   <para>
    PHP içindeki değere göre olağan atama davranışının bir istisnası,
    gönderimle atanan nesnelerle gerçekleşir. Nesneler
    <link linkend="language.oop5.cloning">clone</link> anahtar sözcüğü ile
    doğrudan kopyalanabilir.
   </para>

   <sect2 xml:id="language.operators.assignment.reference">
    <title>Gönderimli atama</title>
    <para>
     Gönderimli atama <literal>$değişken = &amp;$diğerdeğişken;</literal>
     sözdizimi ile desteklenmektedir. 'Gönderimli atama' denince, iki
     değişkenin aynı veriyi gösterdiğini ve birbirlerinden birşeyler
     kopyalamadıklarını anlıyoruz.
    </para>
    <para>
     <example>
      <title>- Gönderimli atama</title>
      <programlisting role="php">
<![CDATA[
<?php
$a = 3;
$b = &$a; // $b, $a'ya bir gönderimdir

print "$a\n"; // 3 basar
print "$b\n"; // 3 basar

$a = 4; // $a değişir

print "$a\n"; // 4 basar
print "$b\n"; // bu da 4 basar, $b, $a'ya bir gönderimdi ve $a değişti

?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     <link linkend="language.oop5.basic.new">new</link> işleci otomatik
     olarak bir gönderim döndürür. Dolayısıyla,
     <link linkend="language.oop5.basic.new">new</link> sonucunu gönderimli
     atamak bir hatadır.
    </para>
    <para>
     Örneğin bu kod bir hata veya uyarı ile sonuçlanır:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class C {}

$o = &new C;
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Parse error: syntax error, unexpected 'new' (T_NEW) in …
// Çözümleme hatası: sözdizimi hatası, beklenmeyen 'new' (T_NEW) in …
]]>
      </screen>
    </informalexample>
    </para>
    <para>
      Gönderimler hakkında daha ayrıntılı bilgi
      edinmek için <link linkend="language.references">Gönderimlerle ilgili
      herşey</link> bölümüne bakınız.
    </para>
   </sect2>
   <sect2 xml:id="language.operators.assignment.arithmetic">
    <title>Aritmetik Atams İşleçleri</title>
    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Örnek</entry>
        <entry>Eşdeğeri</entry>
        <entry>İşlem</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>$a += $b</entry>
        <entry>$a = $a + +$b</entry>
        <entry>Toplama</entry>
       </row>
       <row>
        <entry>$a -= $b</entry>
        <entry>$a = $a - $b</entry>
        <entry>Çıkarma</entry>
       </row>
       <row>
        <entry>$a *= $b</entry>
        <entry>$a = $a * $b</entry>
        <entry>Çarpma</entry>
       </row>
       <row>
        <entry>$a /= $b</entry>
        <entry>$a = $a / $b</entry>
        <entry>Bölme</entry>
       </row>
       <row>
        <entry>$a %= $b</entry>
        <entry>$a = $a % $b</entry>
        <entry>Mod</entry>
       </row>
       <row>
        <entry>$a **= $b</entry>
        <entry>$a = $a ** $b</entry>
        <entry>Üs alma</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </sect2>

   <sect2 xml:id="language.operators.assignment.bitwise">
    <title>Bitsel Atama İşleçleri</title>
    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Örnek</entry>
        <entry>Eşdeğeri</entry>
        <entry>İşlem</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>$a &amp;= $b</entry>
        <entry>$a = $a &amp; $b</entry>
        <entry>Bitsel VE</entry>
       </row>
       <row>
        <entry>$a |= $b</entry>
        <entry>$a = $a | $b</entry>
        <entry>Bitsel VEYA</entry>
       </row>
       <row>
        <entry>$a ^= $b</entry>
        <entry>$a = $a ^ $b</entry>
        <entry>Bitsel XOR</entry>
       </row>
       <row>
        <entry>$a &lt;&lt;= $b</entry>
        <entry>$a = $a &lt;&lt; $b</entry>
        <entry>Sola Öteleme</entry>
       </row>
       <row>
        <entry>$a &gt;&gt;= $b</entry>
        <entry>$a = $a &gt;&gt; $b</entry>
        <entry>Sağa Öteleme</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </sect2>

   <sect2 xml:id="language.operators.assignment.other">
    <title>Diğer Atama İşleçleri</title>
    <informaltable>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Örnek</entry>
        <entry>Eşdeğeri</entry>
        <entry>İşlem</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>$a .= $b</entry>
        <entry>$a = $a . $b</entry>
        <entry>Dize Birleştirme</entry>
       </row>
       <row>
        <entry>$a ??= $b</entry>
        <entry>$a = $a ?? $b</entry>
        <entry>Null Birleşimi</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </sect2>

   <sect2 role="seealso" xml:id="language.operators.assignment.see-also">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><link linkend="language.operators.arithmetic">aritmetik
       işleçler</link></member>
      <member><link linkend="language.operators.bitwise">bitsel
       işleçler</link></member>
      <member><link linkend="language.operators.comparison.coalesce">null
       birleşim işleçleri</link></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.bitwise">
   <title>Bitsel İşleçler</title>
   <simpara>
    Bitsel işleçler, bir tamsayının içindeki belli bitleri 0 ya da 1
    yaparlar.
   </simpara>

   <table>
    <title>Bitsel İşleçler</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Örnek</entry>
       <entry>İsim</entry>
       <entry>Sonuç</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><userinput>$a &amp; $b</userinput></entry>
       <entry>Ve</entry>
       <entry>Hem <varname>$a</varname> hem de <varname>$b</varname>'de 1 olan
       bitler sonuçta 1 yapılır.</entry>
      </row>
      <row>
       <entry><userinput>$a | $b</userinput></entry>
       <entry>Veya</entry>
       <entry><varname>$a</varname> veya <varname>$b</varname>'de 1 olan
       bitler sonuçta 1 yapılır.</entry>
      </row>
      <row>
       <entry><userinput>$a ^ $b</userinput></entry>
       <entry>Ayrıcalıklı Veya</entry>
       <entry>
        Hem <varname>$a</varname> hem de <varname>$b</varname>'de 0 veya 1
        olan bitler sonuçta 0, diğerleri 1 yapılır.
       </entry>
      </row>
      <row>
       <entry><userinput>~ $a</userinput></entry>
       <entry>Değil</entry>
       <entry>
        <varname>$a</varname>'nın 0 olan bitleri 1, 1 olanları 0 yapılır.
       </entry>
      </row>
      <row>
       <entry><userinput>$a &lt;&lt; $b</userinput></entry>
       <entry>Sola kaydırma</entry>
       <entry>
        <varname>$a</varname>'nın bitleri <varname>$b</varname> adım sola
        kaydırılır (her adım ikiyle çarpma işlemine denktir).
       </entry>
      </row>
      <row>
       <entry><userinput>$a &gt;&gt; $b</userinput></entry>
       <entry>Sağa kaydırma</entry>
       <entry>
        <varname>$a</varname>'nın bitleri <varname>$b</varname> adım sağa
        kaydırılır (her adım ikiye bölme işlemine denktir).
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    PHP'de bit kaydırma bir aritmetik işlemdir. Kaydırma sonucu her iki uçtan
    da taşan bitler silinir. Sola kaydırmada sağdan eksilen bitler sıfırlarla
    doldurulur, bu arada işaret biti soldan taşarak silinir, yani sola
    kaydırmada terimin işareti korunmaz. Sağa kaldırmada ise işaret biti
    yerinden oynatılmaz, yani sağa kaydırmada terimin işareti korunur.
   </para>
   <para>
    Bir işlemin <link linkend="language.operators.precedence">öncelik</link>
    almasını istiyorsanız yaylı ayraçları kullanın. Örneğin, <literal>$a
    &amp; $b == true</literal> işleminde önce eşitlik sonra bitsel VE
    uygulanırken <literal>($a &amp; $b) == true</literal> işleminde ise
    önce bitsel VE sonra eşitlik uygulanır.
   </para>
   <para>
    Eğer <literal>&amp;</literal>, <literal>|</literal> ve
    <literal>^</literal> için her iki terim de dize ise terimlerdeki
    karakterlerin ASCII değerleri üzerinde işlem yapılır ve sonuç bir dize
    olur. Tüm diğer durumlarda, her iki terim <link
    linkend="language.types.integer.casting">tamsayıya dönüştürülür</link>
    ve sonuç tamsayı olur.
   </para>
   <para>
    <literal>~</literal> işleci için terim bir dize ise, terimdeki
    karakterlerin ASCII değerleri üzerinde işlem yapılır ve sonuç bir dize
    olur. Aksi takdirde, terim ve sonuç tamsayı olarak ele alınır.
   </para>
   <para>
    <literal>&lt;&lt;</literal> ve <literal>&gt;&gt;</literal> işleçleri için
    her iki terim ve sonuç daima tamsayı olarak ele alınır.
   </para>
  <para>
    <informalexample>
     <para>
      <literallayout>
PHP'nin error_reporting yönergesi gerçekte neler olup bittiğini göstermek
için bitsel değerler kullanır. Sadece bilgilendirmeleri değil hataların
tümünü görmek isterseniz php.ini dosyasında ilgili yere şunu yazın:
<userinput>E_ALL &amp; ~E_NOTICE</userinput>
      </literallayout>
     </para>
     <para>
      <literallayout>
Bu E_ALL için şöyle çalışır:
<userinput>00000000000000000111011111111111</userinput>
Keza E_NOTICE...
<userinput>00000000000000000000000000001000</userinput>
... ve <literal>~</literal> ile ters çevrilerek:
<userinput>11111111111111111111111111110111</userinput>
Son olarak, her iki değer üzerinde etkin bitleri bulmak için
VE (&amp;) işlecini kullanır:
<userinput>00000000000000000111011111110111</userinput>
      </literallayout>
     </para>
     <para>
      <literallayout>
Bunu sağlamanın bir başka yolu da sadece bir değerde veya diğerinde etkin
bitleri bulmak için XOR (<literal>^</literal>) kullanmaktır:
<userinput>E_ALL ^ E_NOTICE</userinput>
      </literallayout>
     </para>
    </informalexample>
   </para>
   <para>
    <informalexample>
     <para>
      <literallayout>
error_reporting yönergesi bitleri etkin kılmayı göstermek için de
kullanılabilir. Sadece hataları ve kurtarılabilir göstermenin yolu:
<userinput>E_ERROR | E_RECOVERABLE_ERROR</userinput>
      </literallayout>
     </para>
     <para>
      <literallayout>
Bu işlem etkin bitleri almak için
<userinput>00000000000000000000000000000001</userinput>
ve
<userinput>00000000000000000001000000000000</userinput>
E_ERROR'ları üzerinde VEYA (<literal>|</literal>) işlecini kullanır:
<userinput>00000000000000000001000000000001</userinput>
      </literallayout>
     </para>
    </informalexample>
   </para>
   <para>
    <example>
     <title>- Tamsayılar üzerinde bitsel işlemler</title>
     <programlisting role="php">
<![CDATA[
<?php
/*
 * Üstteki bölümü yoksayın,
 * çıktıyı iyileştirmek için biçemlemekten başka birşey yapmıyor.
 */

$format = '(%1$2d = %1$04b) = (%2$2d = %2$04b)'
        . ' %3$s (%4$2d = %4$04b)' . "\n";

echo <<<EOH
 ---------     ---------  -- ---------
   sonuç         değer    işl   dnm
 ---------     ---------  -- ---------
EOH;


/*
 * Örnekler burada.
 */

$değerler = array(0, 1, 2, 4, 8);
$dnm = 1 + 4;

echo "\n Bitsel VE \n";
foreach ($değerler as $değer) {
    $sonuç = $değer & $dnm;
    printf($format, $sonuç, $değer, '&', $dnm);
}

echo "\n Bitsel Ayrıcalıklı VEYA \n";
foreach ($değerler as $değer) {
    $sonuç = $değer | $dnm;
    printf($format, $sonuç, $değer, '|', $dnm);
}

echo "\n Bitsel Ayrıcalıklı VEYA (XOR) \n";
foreach ($değerler as $değer) {
    $sonuç = $değer ^ $dnm;
    printf($format, $sonuç, $değer, '^', $dnm);
}
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
 ---------     ---------  -- ---------
   sonuç         değer    işl   dnm
 ---------     ---------  -- ---------
 Bitsel VE
( 0 = 0000) = ( 0 = 0000) & ( 5 = 0101)
( 1 = 0001) = ( 1 = 0001) & ( 5 = 0101)
( 0 = 0000) = ( 2 = 0010) & ( 5 = 0101)
( 4 = 0100) = ( 4 = 0100) & ( 5 = 0101)
( 0 = 0000) = ( 8 = 1000) & ( 5 = 0101)

 Bitsel Ayrıcalıklı VEYA
( 5 = 0101) = ( 0 = 0000) | ( 5 = 0101)
( 5 = 0101) = ( 1 = 0001) | ( 5 = 0101)
( 7 = 0111) = ( 2 = 0010) | ( 5 = 0101)
( 5 = 0101) = ( 4 = 0100) | ( 5 = 0101)
(13 = 1101) = ( 8 = 1000) | ( 5 = 0101)

 Bitsel Ayrıcalıklı VEYA (XOR)
( 5 = 0101) = ( 0 = 0000) ^ ( 5 = 0101)
( 4 = 0100) = ( 1 = 0001) ^ ( 5 = 0101)
( 7 = 0111) = ( 2 = 0010) ^ ( 5 = 0101)
( 1 = 0001) = ( 4 = 0100) ^ ( 5 = 0101)
(13 = 1101) = ( 8 = 1000) ^ ( 5 = 0101)
]]>
     </screen>
    </example>
   </para>
   <para>
    <example>
     <title>- Dizeler üzerinde bitsel işlemler</title>
     <programlisting role="php">
<![CDATA[
<?php
echo 12 ^ 9; // '5' çıktılar

echo "12" ^ "9"; // Gerisilme karakterini çıktılar (ASCII 8)
                 // ('1' (ascii 49)) ^ ('9' (ascii 57)) =  ASCII 8

echo "hallo" ^ "hello"; // Çıktılanan ASCII değerler #0 #4 #0 #0 #0
                        // 'a' ^ 'e' = #4

echo 2 ^ "3"; // 1 çıktılar
              // 2 ^ ((int)"3") == 1

echo "2" ^ 3; // 1 çıktılar
              // ((int)"2") ^ 3 == 1
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>- Tamsayılarda bit kaydırma</title>
     <programlisting role="php">
<![CDATA[
<?php
/*
 * Bunlar örnektir.
 */

echo "\n--- POZİTİF TAMSAYILARDA SAĞA BİT KAYDIRMA ---\n";

$dgr = 4;
$hane = 1;
$snç = $dgr >> $hane;
p($snç, $dgr, '>>', $hane, 'işaret bitinin kopyası sola kaydırıldı');

$dgr = 4;
$hane = 2;
$snç = $dgr >> $hane;
p($snç, $dgr, '>>', $hane);

$dgr = 4;
$hane = 3;
$snç = $dgr >> $hane;
p($snç, $dgr, '>>', $hane, 'bitler sağa kaydırıldı');

$dgr = 4;
$hane = 4;
$snç = $dgr >> $hane;
p($snç, $dgr, '>>', $hane, 'yukarıdakiyle aynı; 0\'dan sonrası kaydırılamaz');


echo "\n--- NEGATİF TAMSAYILARDA SAĞA BİT KAYDIRMA ---\n";

$dgr = -4;
$hane = 1;
$snç = $dgr >> $hane;
p($snç, $dgr, '>>', $hane, 'işaret bitinin kopyası sola kaydırıldı');

$dgr = -4;
$hane = 2;
$snç = $dgr >> $hane;
p($snç, $dgr, '>>', $hane, 'bitler sağa kaydırıldı');

$dgr = -4;
$hane = 3;
$snç = $dgr >> $hane;
p($snç, $dgr, '>>', $hane, 'yukarıdakiyle aynı; -1\'dan sonrası kaydırılamaz');


echo "\n--- POZİTİF TAMSAYILARDA SOLA BİT KAYDIRMA ---\n";

$dgr = 4;
$hane = 1;
$snç = $dgr << $hane;
p($snç, $dgr, '<<', $hane, 'sağ taraf sıfırlarla doldurulur');

$dgr = 4;
$hane = (PHP_INT_SIZE * 8) - 4;
$snç = $dgr << $hane;
p($snç, $dgr, '<<', $hane);

$dgr = 4;
$hane = (PHP_INT_SIZE * 8) - 3;
$snç = $dgr << $hane;
p($snç, $dgr, '<<', $hane, 'işaret bitleri dışa kaydırılır');

$dgr = 4;
$hane = (PHP_INT_SIZE * 8) - 2;
$snç = $dgr << $hane;
p($snç, $dgr, '<<', $hane, 'bitler sola kaydırıldı');


echo "\n--- NEGATİF TAMSAYILARDA SOLA BİT KAYDIRMA ---\n";

$dgr = -4;
$hane = 1;
$snç = $dgr << $hane;
p($snç, $dgr, '<<', $hane, 'sağ taraf sıfırlarla doldurulur');

$dgr = -4;
$hane = (PHP_INT_SIZE * 8) - 3;
$snç = $dgr << $hane;
p($snç, $dgr, '<<', $hane);

$dgr = -4;
$hane = (PHP_INT_SIZE * 8) - 2;
$snç = $dgr << $hane;
p($snç, $dgr, '<<', $hane, 'işaret biti dahil, bitler soldan dışa kaydırıldı');


/*
 * Bundan sonrasını yoksayın; çıktıyı biçemlemekten başka bir şey yapmıyor.
 */

function p($snç, $dgr, $op, $hane, $ilt = '') {
    $format = '%0' . (PHP_INT_SIZE * 8) . "b\n";

    printf("İfade: %d = %d %s %d\n", $snç, $dgr, $op, $hane);

    echo " Onluk:\n";
    printf("  değer=%d\n", $dgr);
    printf("  sonuç=%d\n", $snç);

    echo " İkilik:\n";
    printf('  değer=' . $format, $dgr);
    printf('  sonuç=' . $format, $snç);

    if ($ilt) {
        echo " DİKKAT: $ilt\n";
    }

    echo "\n";
}
?>
]]>
     </programlisting>
     &example.outputs.32bit;
     <screen>
<![CDATA[

--- POZİTİF TAMSAYILARDA SAĞA BİT KAYDIRMA ---
İfade: 2 = 4 >> 1
 Onluk:
  değer=4
  sonuç=2
 İkilik:
  değer=000000000000000000000000000100
  sonuç=000000000000000000000000000010
 DİKKAT: işaret bitinin kopyası sola kaydırıldı

İfade: 1 = 4 >> 2
 Onluk:
  değer=4
  sonuç=1
 İkilik:
  değer=000000000000000000000000000100
  sonuç=000000000000000000000000000001

İfade: 0 = 4 >> 3
 Onluk:
  değer=4
  sonuç=0
 İkilik:
  değer=000000000000000000000000000100
  sonuç=000000000000000000000000000000
 DİKKAT: bitler sağa kaydırıldı

İfade: 0 = 4 >> 4
 Onluk:
  değer=4
  sonuç=0
 İkilik:
  değer=000000000000000000000000000100
  sonuç=000000000000000000000000000000
 DİKKAT: yukarıdakiyle aynı; 0'dan sonrası kaydırılamaz


--- NEGATİF TAMSAYILARDA SAĞA BİT KAYDIRMA ---
İfade: -2 = -4 >> 1
 Onluk:
  değer=-4
  sonuç=-2
 İkilik:
  değer=111111111111111111111111111100
  sonuç=111111111111111111111111111110
 DİKKAT: işaret bitinin kopyası sola kaydırıldı

İfade: -1 = -4 >> 2
 Onluk:
  değer=-4
  sonuç=-1
 İkilik:
  değer=111111111111111111111111111100
  sonuç=111111111111111111111111111111
 DİKKAT: bitler sağa kaydırıldı

İfade: -1 = -4 >> 3
 Onluk:
  değer=-4
  sonuç=-1
 İkilik:
  değer=111111111111111111111111111100
  sonuç=111111111111111111111111111111
 DİKKAT: yukarıdakiyle aynı; -1'dan sonrası kaydırılamaz


--- POZİTİF TAMSAYILARDA SOLA BİT KAYDIRMA ---
İfade: 8 = 4 << 1
 Onluk:
  değer=4
  sonuç=8
 İkilik:
  değer=000000000000000000000000000100
  sonuç=000000000000000000000000001000
 DİKKAT: sağ taraf sıfırlarla doldurulur

İfade: 4611686018427387904 = 4 << 60
 Onluk:
  değer=4
  sonuç=4611686018427387904
 İkilik:
  değer=000000000000000000000000000100
  sonuç=010000000000000000000000000000

İfade: -9223372036854775808 = 4 << 61
 Onluk:
  değer=4
  sonuç=-9223372036854775808
 İkilik:
  değer=000000000000000000000000000100
  sonuç=100000000000000000000000000000
 DİKKAT: işaret bitleri dışa kaydırılır

İfade: 0 = 4 << 62
 Onluk:
  değer=4
  sonuç=0
 İkilik:
  değer=000000000000000000000000000100
  sonuç=000000000000000000000000000000
 DİKKAT: bitler sola kaydırıldı


--- NEGATİF TAMSAYILARDA SOLA BİT KAYDIRMA ---
İfade: -8 = -4 << 1
 Onluk:
  değer=-4
  sonuç=-8
 İkilik:
  değer=111111111111111111111111111100
  sonuç=111111111111111111111111111000
 DİKKAT: sağ taraf sıfırlarla doldurulur

İfade: -9223372036854775808 = -4 << 61
 Onluk:
  değer=-4
  sonuç=-9223372036854775808
 İkilik:
  değer=111111111111111111111111111100
  sonuç=100000000000000000000000000000

İfade: 0 = -4 << 62
 Onluk:
  değer=-4
  sonuç=0
 İkilik:
  değer=111111111111111111111111111100
  sonuç=000000000000000000000000000000
 DİKKAT: işaret biti dahil, bitler soldan dışa kaydırıldı
]]>
     </screen>
     &example.outputs.64bit;
     <screen>
<![CDATA[

--- POZİTİF TAMSAYILARDA SAĞA BİT KAYDIRMA ---
İfade: 2 = 4 >> 1
 Onluk:
  değer=4
  sonuç=2
 İkilik:
  değer=0000000000000000000000000000000000000000000000000000000000000100
  sonuç=0000000000000000000000000000000000000000000000000000000000000010
 DİKKAT: işaret bitinin kopyası sola kaydırıldı

İfade: 1 = 4 >> 2
 Onluk:
  değer=4
  sonuç=1
 İkilik:
  değer=0000000000000000000000000000000000000000000000000000000000000100
  sonuç=0000000000000000000000000000000000000000000000000000000000000001

İfade: 0 = 4 >> 3
 Onluk:
  değer=4
  sonuç=0
 İkilik:
  değer=0000000000000000000000000000000000000000000000000000000000000100
  sonuç=0000000000000000000000000000000000000000000000000000000000000000
 DİKKAT: bitler sağa kaydırıldı

İfade: 0 = 4 >> 4
 Onluk:
  değer=4
  sonuç=0
 İkilik:
  değer=0000000000000000000000000000000000000000000000000000000000000100
  sonuç=0000000000000000000000000000000000000000000000000000000000000000
 DİKKAT: yukarıdakiyle aynı; 0'dan sonrası kaydırılamaz


--- NEGATİF TAMSAYILARDA SAĞA BİT KAYDIRMA ---
İfade: -2 = -4 >> 1
 Onluk:
  değer=-4
  sonuç=-2
 İkilik:
  değer=1111111111111111111111111111111111111111111111111111111111111100
  sonuç=1111111111111111111111111111111111111111111111111111111111111110
 DİKKAT: işaret bitinin kopyası sola kaydırıldı

İfade: -1 = -4 >> 2
 Onluk:
  değer=-4
  sonuç=-1
 İkilik:
  değer=1111111111111111111111111111111111111111111111111111111111111100
  sonuç=1111111111111111111111111111111111111111111111111111111111111111
 DİKKAT: bitler sağa kaydırıldı

İfade: -1 = -4 >> 3
 Onluk:
  değer=-4
  sonuç=-1
 İkilik:
  değer=1111111111111111111111111111111111111111111111111111111111111100
  sonuç=1111111111111111111111111111111111111111111111111111111111111111
 DİKKAT: yukarıdakiyle aynı; -1'dan sonrası kaydırılamaz


--- POZİTİF TAMSAYILARDA SOLA BİT KAYDIRMA ---
İfade: 8 = 4 << 1
 Onluk:
  değer=4
  sonuç=8
 İkilik:
  değer=0000000000000000000000000000000000000000000000000000000000000100
  sonuç=0000000000000000000000000000000000000000000000000000000000001000
 DİKKAT: sağ taraf sıfırlarla doldurulur

İfade: 4611686018427387904 = 4 << 60
 Onluk:
  değer=4
  sonuç=4611686018427387904
 İkilik:
  değer=0000000000000000000000000000000000000000000000000000000000000100
  sonuç=0100000000000000000000000000000000000000000000000000000000000000

İfade: -9223372036854775808 = 4 << 61
 Onluk:
  değer=4
  sonuç=-9223372036854775808
 İkilik:
  değer=0000000000000000000000000000000000000000000000000000000000000100
  sonuç=1000000000000000000000000000000000000000000000000000000000000000
 DİKKAT: işaret bitleri dışa kaydırılır

İfade: 0 = 4 << 62
 Onluk:
  değer=4
  sonuç=0
 İkilik:
  değer=0000000000000000000000000000000000000000000000000000000000000100
  sonuç=0000000000000000000000000000000000000000000000000000000000000000
 DİKKAT: bitler sola kaydırıldı


--- NEGATİF TAMSAYILARDA SOLA BİT KAYDIRMA ---
İfade: -8 = -4 << 1
 Onluk:
  değer=-4
  sonuç=-8
 İkilik:
  değer=1111111111111111111111111111111111111111111111111111111111111100
  sonuç=1111111111111111111111111111111111111111111111111111111111111000
 DİKKAT: sağ taraf sıfırlarla doldurulur

İfade: -9223372036854775808 = -4 << 61
 Onluk:
  değer=-4
  sonuç=-9223372036854775808
 İkilik:
  değer=1111111111111111111111111111111111111111111111111111111111111100
  sonuç=1000000000000000000000000000000000000000000000000000000000000000

İfade: 0 = -4 << 62
 Onluk:
  değer=-4
  sonuç=0
 İkilik:
  değer=1111111111111111111111111111111111111111111111111111111111111100
  sonuç=0000000000000000000000000000000000000000000000000000000000000000
 DİKKAT: işaret biti dahil, bitler soldan dışa kaydırıldı
]]>
     </screen>
    </example>
  </para>
   <warning>
    <para>
     <literal>PHP_INT_MAX</literal>'ın ötesindeki sayılar üzerinde bitsel
     işlemler için <link linkend="book.gmp">gmp</link> eklentisindeki
     işlevleri kullanın.
    </para>
   </warning>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
<!-- <link linkend="language.oop5.basic.class.class">::class</link> -->
      <member><function>pack</function></member>
      <member><function>unpack</function></member>
      <member><function>gmp_and</function></member>
      <member><function>gmp_or</function></member>
      <member><function>gmp_xor</function></member>
      <member><function>gmp_testbit</function></member>
      <member><function>gmp_clrbit</function></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.comparison">
   <title>Karşılaştırma İşleçleri</title>
   <simpara>
    Karşılaştırma işleçleri isminden de anlaşılacağı üzere iki değerin
    karşılaştırılmasını sağlarlar. Çeşitli veri türleri arasındaki
    karşılaştırma örneklerinin yer aldığı <link linkend="types.comparisons"
    >tür karşılaştırma tabloları</link> ilginizi çekebilir.
   </simpara>
   <table>
    <title>Karşılaştırma İşleçleri</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Örnek</entry>
       <entry>İsim</entry>
       <entry>Sonuç</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><userinput>$a == $b</userinput></entry>
       <entry>Eşittir</entry>
       <entry>Tür dönüşümünden sonra, <varname>$a</varname> ve
         <varname>$b</varname> aynı değere sahipse sonuç &true; olur.</entry>
      </row>
      <row>
       <entry><userinput>$a === $b</userinput></entry>
       <entry>Aynıdır</entry>
       <entry>
        <varname>$a</varname> ve <varname>$b</varname> aynı değere sahipse ve
        türleri de aynıysa sonuç &true; olur.
       </entry>
      </row>
      <row>
       <entry><userinput>$a != $b</userinput></entry>
       <entry>Eşit değildir</entry>
       <entry>Tür dönüşümünden sonra, <varname>$a</varname> ve
        <varname>$b</varname> aynı değere sahip değilse sonuç &true; olur.
       </entry>
      </row>
      <row>
       <entry><userinput>$a &lt;&gt; $b</userinput></entry>
       <entry>Eşit değildir</entry>
       <entry>Tür dönüşümünden sonra, <varname>$a</varname> ve
        <varname>$b</varname> aynı değere sahip değilse sonuç &true; olur.
       </entry>
      </row>
      <row>
       <entry><userinput>$a !== $b</userinput></entry>
       <entry>Farklıdır</entry>
       <entry>
        <varname>$a</varname> ve <varname>$b</varname> aynı değere sahip
        değilse veya türleri aynı değilse sonuç &true; olur.
       </entry>
      </row>
      <row>
       <entry><userinput>$a &lt; $b</userinput></entry>
       <entry>Küçüktür</entry>
       <entry><varname>$a</varname> kesin olarak <varname>$b</varname>'den
       küçükse sonuç &true; olur.</entry>
      </row>
      <row>
       <entry><userinput>$a &gt; $b</userinput></entry>
       <entry>Büyüktür</entry>
       <entry><varname>$a</varname> kesin olarak <varname>$b</varname>'den
       büyükse sonuç &true; olur.</entry>
      </row>
      <row>
       <entry><userinput>$a &lt;= $b</userinput></entry>
       <entry>Küçük veya eşittir</entry>
       <entry><varname>$a</varname>, <varname>$b</varname>'den küçük veya ona
       eşitse sonuç &true; olur.</entry>
      </row>
      <row>
       <entry><userinput>$a &gt;= $b</userinput></entry>
       <entry>Büyük veya eşittir</entry>
       <entry><varname>$a</varname>, <varname>$b</varname>'den büyük veya ona
       eşitse sonuç &true; olur.</entry>
      </row>
      <row>
       <entry>$a &lt;=&gt; $b</entry>
       <entry>Mekik</entry>
       <entry>
        <varname>$a</varname> küçük, eşit veya büyük <varname>$b</varname>
        olduğunda, bir tamsayı da sırasıyla küçük, eşit veya büyük sıfırdır.
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Her iki terim de sayısal dize ise veya bir terim sayı ve diğeri sayısal
    dizeyse, karşılaştırma sayısal olarak yapılır. Bu kurallar ayrıca
    <link linkend="control-structures.switch">switch</link> deyimine de
    uygulanır. <literal>===</literal> veya <literal>!==</literal> ile tür
    ve dolayısıyla değer karşılaştırıldığından böyle karşılaştırmalarda
    tür dönüşümü yapılmaz.
   </para>

   <warning>
    <para>
     PHP 8.0.0'dan önce, bir dize bir sayı veya sayısal bir dizeyle
     karşılaştırılırsa, karşılaştırma yapılmadan önce dize bir sayıya
     dönüştürülürdü. Bu, aşağıdaki örnekte görülebileceği gibi şaşırtıcı
     sonuçlara yol açabilir:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
var_dump(0 == "a");
var_dump("1" == "01");
var_dump("10" == "1e1");
var_dump(100 == "1e2");

switch ("a") {
case 0:
    echo "0";
    break;
case "a":
    echo "a";
    break;
}
?>
]]>
      </programlisting>
      &example.outputs.7;
      <screen>
<![CDATA[
bool(true)
bool(true)
bool(true)
bool(true)
0
]]>
      </screen>
      &example.outputs.8;
      <screen>
<![CDATA[
bool(false)
bool(true)
bool(true)
bool(true)
a
]]>
      </screen>
     </informalexample>
    </para>
   </warning>

   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// Tamsayılar
echo 1 <=> 1; // 0
echo 1 <=> 2; // -1
echo 2 <=> 1; // 1

// Gerçeller
echo 1.5 <=> 1.5; // 0
echo 1.5 <=> 2.5; // -1
echo 2.5 <=> 1.5; // 1

// Dizeler
echo "a" <=> "a"; // 0
echo "a" <=> "b"; // -1
echo "b" <=> "a"; // 1

echo "a" <=> "aa"; // -1
echo "zz" <=> "aa"; // 1

// Diziler
echo [] <=> []; // 0
echo [1, 2, 3] <=> [1, 2, 3]; // 0
echo [1, 2, 3] <=> []; // 1
echo [1, 2, 3] <=> [1, 2, 1]; // 1
echo [1, 2, 3] <=> [1, 2, 4]; // -1

// Nesneler
$a = (object) ["a" => "b"];
$b = (object) ["a" => "b"];
echo $a <=> $b; // 0

$a = (object) ["a" => "b"];
$b = (object) ["a" => "c"];
echo $a <=> $b; // -1

$a = (object) ["a" => "c"];
$b = (object) ["a" => "b"];
echo $a <=> $b; // 1

// sadece değerler karşılaştırılmaz, anahtarlar da eşleşmeli
$a = (object) ["a" => "b"];
$b = (object) ["b" => "b"];
echo $a <=> $b; // 1

?>
]]>

     </programlisting>
    </informalexample>
   </para>

   <para>
    Çeşitli türler arasında karşılaştırma aşağıdaki tabloya ve tablodaki
    sıralamaya uygun olarak yapılır.
   </para>
   <table xml:id="language.operators.comparison.types">
    <title>Çeşitli Türlerin Karşılaştırılması</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>1. Terimin Türü</entry>
       <entry>2. Terimin Türü</entry>
       <entry>Sonuç</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><type>null</type> veya <type>string</type></entry>
       <entry><type>string</type></entry>
       <entry>&null;, "" dizgesine dönüştürülür, sayısal veya alfabetik
       karşılaştırma yapılır.</entry>
      </row>
      <row>
       <entry><type>bool</type> veya <type>null</type></entry>
       <entry>herhangi bir tür</entry>
       <entry>Her iki tarafta <type>bool</type> türüne dönüşümden sonra
         &false; &lt; &true; karşılaştırması yapılır</entry>
      </row>
      <row>
       <entry><type>object</type></entry>
       <entry><type>object</type></entry>
       <entry>Yerleşik sınıflar kendi karşılaştırmalarını tanımlayabilir.
       Farklı sınıflar karşılaştırılamazlar. Aynı sınıflar için bkz: <link
       linkend="language.oop5.object-comparison">Nesne karşılaştırması</link>
       </entry>
      </row>
      <row>
       <entry><type>string</type>, <type>resource</type>, <type>int</type>
         veya <type>float</type></entry>
       <entry><type>string</type>, <type>resource</type>, <type>int</type>
         veya <type>float</type></entry>
       <entry>Diziler ve özkaynaklar sayılara dönüştürülür, sayısal
       karşılaştırma yapılır.</entry>
      </row>
      <row>
       <entry><type>array</type></entry>
       <entry><type>array</type></entry>
       <entry>Daha az üyeye sahip dizi diğerinden küçüktür. Eğer 1. terimin
       anahtarı 2. terimde yoksa diziler karşılaştırılamaz. Karşılaştırma
       daima değerler karşılaştırılarak yapılır (aşağıdaki örneğe
       bakınız).</entry>
      </row>
      <row>
       <entry><type>object</type></entry>
       <entry>herhangi bir tür</entry>
       <entry><type>object</type> daima büyüktür.</entry>
      </row>
      <row>
       <entry><type>array</type></entry>
       <entry>herhangi bir tür</entry>
       <entry><type>array</type> daima büyüktür</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    <example>
     <title>- Bool/null karşılaştırması</title>
     <programlisting role="php">
<![CDATA[
<?php
// Bool ve null daima bool gibi karşılaştırılır.
var_dump(1 == TRUE);  // TRUE - (bool)1 == TRUE ile aynı
var_dump(0 == FALSE); // TRUE - (bool)0 == FALSE ile aynı
var_dump(100 < TRUE); // FALSE - (bool)100 < TRUE ile aynı
var_dump(-10 < FALSE);// FALSE - (bool)-10 < FALSE ile aynı
var_dump(min(-100, -10, NULL, 10, 100)); // NULL - (bool)NULL < (bool)-100 is FALSE < TRUE
?>
]]>
     </programlisting>
    </example>
   </para>


   <para>
    <example>
     <title>- Özetle Standard Dizi Karşılaştırması</title>
     <programlisting role="php">
<![CDATA[
<?php
// Diziler bunun gibi standart karşılaştırma işleçleri ile karşılaştırılır
function standard_dizi_karşılaştır($trm1, $trm2)
{
    if (count($ter1) < count($ter2)) {
      return -1;                          // $ter1 < $ter2
    } elseif (count($op1) > count($op2)) {
        return 1;                         // $ter1 > $ter2
    }
    foreach ($ter1 as $anh => $değ) {
        if (!array_key_exists($anh, $ter2)) {
            return null;                   // karşılaştırılamaz
        } elseif ($değ < $ter2[$anh]) {
            return -1;
        } elseif ($değ > $ter2[$anh]) {
            return 1;
        }
    }
    return 0; // $ter1 == $ter2
}
?>
]]>
     </programlisting>
    </example>
   </para>

   <warning>
    <title>Kayan noktalı sayıların karşılaştırılması</title>
    <para>
     <type>float</type> türlerinin dahili gösteriminden dolayı iki
     <type>float</type> sayının eşitliğine bakamazsınız.
    </para>

    <para>
     Bu konuda daha ayrıntıl bilgi için <type>float</type> türünün belgesine
     bakınız.
    </para>
   </warning>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><function>strcasecmp</function></member>
      <member><function>strcmp</function></member>
      <member><link linkend="language.operators.array">Dizi
       işleçleri</link></member>
      <member><link linkend="language.types">Türler</link></member>
     </simplelist>
    </para>
   </sect2>

   <sect2 xml:id="language.operators.comparison.ternary">
    <title>Üç Terimli İşleç</title>
    <para>
     Diğer bir karşılaştırma işleci <literal>?:</literal> (üç terimli)
     işlecidir.
     <example>
      <title>- Öntanımlı bir değer atama</title>
      <programlisting role="php">
<![CDATA[
<?php
// Üç terimli işleç için kullanım örneği
$action = (empty($_POST['action'])) ? 'default' : $_POST['action'];

// Yukarıdaki kod ile buradaki if/else deyimi aynı işlemi yapar.
if (empty($_POST['action'])) {
    $action = 'default';
} else {
    $action = $_POST['action'];
}

?>
]]>
      </programlisting>
     </example>
     <literal>(ifade1) ? (ifade2) : (ifade3)</literal> ifadesinin sonucu,
     <replaceable>ifade1</replaceable> doğruysa
     <replaceable>ifade2</replaceable> değilse
     <replaceable>ifade3</replaceable>'dir.
    </para>
    <para>
     Üç terimli işlecin orta parçasını dışarda bırakmak mümkündür.
     <literal>ifade1 ?: ifade3</literal> ifadesi
     <replaceable>ifade1</replaceable> &true; ise
     <replaceable>ifade1</replaceable> ile,
     değilse <replaceable>ifade3</replaceable> ile döner.
    </para>
    <note>
     <simpara>
      Üç terimli işleç aslında bir ifadedir, dolayısıyla sonucu bir
      değişkene atanamaz, fakat bir deyimin sonucuna atanabilir.
      Bir değişkeni gönderimli döndürmek istediğiniz
      takdirde bu önem kazanır. Gönderimli olarak değer döndüren bir işlevde
      <literal>return $var == 42 ? $a : $b;</literal> deyimi bu bakımdan
      çalışmaz ve bir uyarı gösterilir.
     </simpara>
    </note>
    <note>
     <para>
      Üç terimli işleçleri parantezsiz olarak iç içe kullanmanız önerilmez.
      PHP'nin böyle bir
      işlemin tek bir deyimde yapılmak istenmesi durumundaki davranışı
      diğer dillerle karşılaştırıldığında beklendiği gibi olmayabilir.
      Aslında PHP 8.0.0'dan önce, üçlü ifadeler diğer programlama dilleri
      gibi sağdan sola yerine soldan sağa değerlendiriliyordu.
      PHP 7.4.0 itibariyle soldan sağa ilişkilendirmeye güvenilmesi
      önerilmemekte olup PHP 8.0.0 itibariyle üçlü işlecin değerlendirmesi
      yönsüzdür.
      <example>
       <title>- İç içe üç terimli davranışı</title>
       <programlisting role="php">
<![CDATA[
<?php
// ilk bakışta aşağıdaki deyimin sonucu 'true' olacak sanılır.
echo (true ? 'true' : false ? 't' : 'f');

// ancak gerçekte çıktı 't' olur, PHP 8.0.0 öncesinde.
// Çünkü üç terimli ifade soldan ilişkilendirilir.

// Aynı deyimi şöyle yazarsanız, durum anlaşılır hale gelir
echo ((true ? 'true' : false) ? 't' : 'f');

// Burada, ilk ifade mantıksal olarak doğru olduğundan sonuç 'true'
// olacak, böylece ikinci üç terimlinin ilk terimi 'true' olacak ve
// ikinci üç terimliden 't' dönecektir.
?>
]]>
       </programlisting>
      </example>
     </para>
    </note>
   </sect2>

   <sect2 xml:id="language.operators.comparison.coalesce">
    <title>Null kaynaşma işleci</title>
    <para>
     "??" null kaynaşma işleci adını alır.
     <example>
      <title>- Öntanımlı değer atama</title>
      <programlisting role="php">
<![CDATA[
<?php
// Null kaynaşma işleci için kullanım örneği
$action = $_POST['action'] ?? 'default';

// Yukarıdaki satır, bu if/else deyimine esdeğerdir.
if (isset($_POST['action'])) {
    $action = $_POST['action'];
} else {
    $action = 'default';
}

?>
]]>
      </programlisting>
     </example>
     <literal>(ifade1) ?? (ifade2)</literal> ifadesinin sonucu,
     <replaceable>ifade1</replaceable> &null;
     ise <replaceable>ifade2</replaceable>
     değilse <replaceable>ifade1</replaceable>'dir.
    </para>
    <para>
     Aslında, bu işleç sol taraf değeri mevcut değilse
     <function>isset</function> gibi bir uyarı ya da bilgi çıktılamaz.
     Bu, özellikle dizi anahtarlarında kullanışlıdır.
    </para>
    <note>
     <simpara>
      Null kaynaşma işleci bir ifade olup bir değişkene atanmaz ama bir deyimin
      sonucuna atanabilir. Bir değişkeni gönderimli döndürmek istiyorsanız bunu
      bilmek önemlidir. Gönderimli döndüren bir işlevde
      <literal>return $foo ?? $bar;</literal> deyimi bu nedenle çalışmaz ve bir
      uyarı çıktılanır.
     </simpara>
    </note>
    <note>
     <para>
      Null kaynaşma işleci basit iç içeliğe izi verir:
      <example>
       <title>- İçiçe null kaynaşma işleci</title>
       <programlisting role="php">
<![CDATA[
<?php

$foo = null;
$bar = null;
$baz = 1;
$qux = 2;

echo $foo ?? $bar ?? $baz ?? $qux; // 1 basar

?>
]]>
       </programlisting>
      </example>
     </para>
    </note>
   </sect2>

  </sect1>

  <sect1 xml:id="language.operators.errorcontrol">
   <title>Hata Denetim İşleçleri</title>
   <simpara>
    PHP tek bir hata denetim işlecini destekler: kuyruklu a imi
    (<literal>@</literal>). PHP'de bir deyimin başına getirildiğinde,
    bu deyimin üreteceği olası hata iletileri engellenir.
   </simpara>
   <para>
    <function>set_error_handler</function> ile özel bir hata işleyici işlevi
    ayarlanırsa, tanılama bastırılmış olsa bile, özel hata işleyici
    <function>error_reporting</function> işlevini çağırmalı ve aşağıdaki
    şekilde kullanılan <literal>@</literal> işlecini doğrulamalıdır:

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
function my_error_handler($err_no, $err_msg, $filename, $linenum) {
    if (!(error_reporting() & $err_no)) {
        return false; // Sustu
    }
    // ...
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>

   <warning>
    <para>
     PHP 8.0.0'dan önce, özel hata işleyicisine aktarılan önem derecesi değeri,
     tanılama bastırıldıysa her zaman <literal>0</literal> idi. Bu artık PHP
     8.0.0'dan itibaren geçerli değildir.
    </para>
   </warning>

   <simpara>
    İfade tarafından üretilenhata iletisi, <function>get_error_last</function>
    işlevinden dönen dizinin <literal>"message"</literal> elemanında bulunur.
    Bu işlevin sonucu her hatada değişir, bu bakımdan sonuca yeterince kısa
    sürede bakmak gerekir.
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* Kasıtlı dosya hatası */
$dosyam = @file ('var_olmayan_dosya') or
    die ("Dosya açılamadı: hata '" . get_error_last()['message'] . "'");

// İfadelerle çalışır ama işlevlerle çalışmaz:
$değer = @$cache[$key];
// $key indisi mevcut değilse bir uyarı çıktılanır.

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <simpara>
     Kuyruklu a işleci sadece <link linkend="language.expressions"
     >ifadeler</link>in başında kullanıldığında çalışır. Kısaca: Bir değer
     elde edilebilen herşeyin başına <literal>@</literal> getirilebilir.
     Örneğin, değişkenlerin işlev veya <function>include</function>
     çağrılarının, sabitlerin ve benzerlerinin başına <literal>@</literal>
     getirilebilir. Ama işlev veya sınıf tanımlarının veya
     <literal>if</literal> ve &foreach; gibi denetim
     yapılarının başına <literal>@</literal> konamaz.
    </simpara>
   </note>
   <warning>
    <para>
     PHP 8.0.0 öncesinde, <literal>@</literal> hata denetim işleci ile
     betiğin çalışmasını sonlandıracak önemli hataların raporlanmasını
     iptal etmek mümkündü.
     Bu bakımdan, işleç örneğin bir işlevden kaynaklanabilecek hataları
     bastırmak için kullanılıyorsa, işlev tanımında yapılan yazım hataları
     nedeniyle veya işlevin yokluğu halinde, ne olup bittiği anlaşılamadan
     betik sonlanabiliyordu.
    </para>
   </warning>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><function>error_reporting</function></member>
      <member><link linkend="ref.errorfunc">Hata İşleme İşlevleri</link></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.execution">
   <title>Çalıştırma İşleci</title>
   <para>
    PHP tek bir çalıştırma işlecini destekmektedir: ters tırnak imleri (``).
    Bunların bildiğiniz tek tırnaklar olmadığına dikkat edin! Ters tırnak
    imlerinin arasına yazılmış komutları PHP komut satırında çalıştıracak ve
    çıktısını döndürecektir. Yani, komut satırına birşey çıktılanmaz; ama
    sonucu bir değişkene atayabilirsiniz. Çalıştırma işleci
    <function>shell_exec</function> işlevinin yaptığı işi yapar.
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$output = `ls -al`;
echo "<pre>$output</pre>";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <para>
     <function>shell_exec</function> işlevi etkin
     değilse, çalıştırma işleci etkin değildir.
    </para>
   </note>
   <note>
    <para>
     Bazı başka dillerin aksine, tek tırnak imlerinin çift tırnaklı dizeler içinde
     özel bir anlamı yoktur.
    </para>
   </note>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><link linkend="ref.exec">Program Çalıştırma
       İşlevleri</link></member>
      <member><function>popen</function></member>
      <member><function>proc_open</function></member>
      <member><link linkend="features.commandline">PHP'nin komut satırından
       kullanılması</link></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.increment">
   <title>Arttırım ve Eksiltim İşleçleri</title>
   <para>
    PHP, C tarzı önceden ve sonradan arttırım ve eksiltim işleçlerini
    destekler.
   </para>
   <note>
    <simpara>
     Arttırım ve eksiltim işleçleri sadece sayıları ve dizeleri etkiler.
     Diziler, nesneler, mantıksallar ve özkaynaklar etkilenmez.
     &null; değerini eksiltmenin bir etkisi yoktur fakat arttırmanın sonucu
     <literal>1</literal>'dir.
    </simpara>
   </note>
   <table>
    <title>Arttırım ve Eksiltim İşleçleri</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Örnek</entry>
       <entry>İsim</entry>
       <entry>Etkisi</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><userinput>++$a</userinput></entry>
       <entry>Önceden arttırım</entry>
       <entry><varname>$a</varname> bir arttırıldıktan sonra
       döndürülür.</entry>
      </row>
      <row>
       <entry><userinput>$a++</userinput></entry>
       <entry>Sonradan arttırım</entry>
       <entry><varname>$a</varname> döndürüldükten sonra değeri bir
       arttırılır.</entry>
      </row>
      <row>
       <entry><userinput>--$a</userinput></entry>
       <entry>Önceden eksiltim</entry>
       <entry><varname>$a</varname> bir eksiltildikten sonra
       döndürülür.</entry>
      </row>
      <row>
       <entry><userinput>$a--</userinput></entry>
       <entry>Sonradan eksiltim</entry>
       <entry><varname>$a</varname> döndürüldükten sonra değeri bir
       eksiltilir.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    Basit bir betik örneği:
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
echo "<h3>Sonradan arttırım</h3>\n";
$a = 5;
echo "5 olmalı: " . $a++ . "<br />\n";
echo "6 olmalı: " . $a . "<br />\n";

echo "<h3>Önceden arttırım</h3>\n";
$a = 5;
echo "6 olmalı: " . ++$a . "<br />\n";
echo "6 olmalı: " . $a . "<br />\n";

echo "<h3>Sonradan eksiltim</h3>\n";
$a = 5;
echo "5 olmalı: " . $a-- . "<br />\n";
echo "4 olmalı: " . $a . "<br />\n";

echo "<h3>Önceden eksiltim</h3>\n";
$a = 5;
echo "4 olmalı: " . --$a . "<br />\n";
echo "4 olmalı: " . $a . "<br />\n";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    PHP, karakter değişkenleri üzerinde çalışırken C'nin değil Perl'in
    yöntemlerini izler. Örneğin, PHP ve Perl'de
    <literal>$a = 'Z'; $a++;</literal> ifadesi <literal>$a</literal>
    içinde 'AA' değerini döndürürken, C'de <literal>a = 'Z'; a++;</literal>
    ifadesi <literal>a</literal> içinde'[' döndürür. <literal>'Z'</literal>
    için ASCII değer 90, <literal>'['</literal> için 91'dir.
    Karakterlerin arttırılabileceğini fakat azaltılamayacağını ve sadece
    ASCII harflerin ve rakamların (a-z ve A-Z, 0-9) desteklendiğine dikkat
    ediniz. Diğer karakterler üzerinde arttırım ve eksiltim etkisiz olup
    özgün değer değişmeden döndürürlür.
    <example>
     <title>- Karakter değişkenleri üzerinde aritmetik işlemler</title>
     <programlisting role="php">
<![CDATA[
<?php
echo '== Harfler ==' . PHP_EOL;
$i = 'W';
for ($n=0; $n<6; $n++) {
    echo ++$s . PHP_EOL;
}
// Rakam karakterleri farklı davranır
echo '== Rakamlar ==' . PHP_EOL;
$d = 'A8';
for ($n=0; $n<6; $n++) {
    echo ++$d . PHP_EOL;
}
$d = 'A08';
for ($n=0; $n<6; $n++) {
    echo ++$d . PHP_EOL;
}
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
== Harfler ==
X
Y
Z
AA
AB
AC
== Rakamlar ==
A9
B0
B1
B2
B3
B4
A09
A10
A11
A12
A13
A14
]]>
     </screen>
    </example>
   </para>
   <para>
    Mantıksal değerlere arttırım ve eksiltim uygulamanın bir etkisi olmaz.
   </para>
  </sect1>

  <sect1 xml:id="language.operators.logical">
   <title>Mantıksal İşleçler</title>

   <table>
    <title>Mantıksal İşleçler</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Örnek</entry>
       <entry>İsim</entry>
       <entry>Sonuç</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><userinput>$a and $b</userinput></entry>
       <entry>Ve</entry>
       <entry><varname>$a</varname> ve <varname>$b</varname> her ikisi de
       doğruysa sonuç doğrudur (&true;).</entry>
      </row>
      <row>
       <entry><userinput>$a or $b</userinput></entry>
       <entry>Veya</entry>
       <entry><varname>$a</varname> veya <varname>$b</varname> doğruysa sonuç
       doğrudur.</entry>
      </row>
      <row>
       <entry><userinput>$a xor $b</userinput></entry>
       <entry>Ayrıcalıklı Veya</entry>
       <entry><varname>$a</varname> veya <varname>$b</varname> doğruysa sonuç
       doğru, her ikiside doğruysa sonuç yanlıştır (&false;).</entry>
      </row>
      <row>
       <entry><userinput>! $a</userinput></entry>
       <entry>Değil</entry>
       <entry><varname>$a</varname> doğru değilse sonuç doğrudur.</entry>
      </row>
      <row>
       <entry><userinput>$a &amp;&amp; $b</userinput></entry>
       <entry>Ve</entry>
       <entry><varname>$a</varname> ve <varname>$b</varname> her ikisi de
       doğruysa sonuç doğrudur.</entry>
      </row>
      <row>
       <entry><userinput>$a || $b</userinput></entry>
       <entry>Veya</entry>
       <entry><varname>$a</varname> veya <varname>$b</varname> doğruysa sonuç
       doğrudur.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
    Ve, Veya işleçlerinin iki farklı türü olmasının sebebi önceliklerinin
    farklı oluşudur. (Bakınız: <link linkend="language.operators.precedence"
    >İşleç Önceliği</link>.)
   </simpara>
   <example>
    <title>- Örneklerle mantıksal işleçler</title>
    <programlisting role="php">
<![CDATA[
<?php
// --------------------
// Aşağıdaki ifadelerde ilk terim sonucu belirlediğinden ikinci
// terime hiç bakılmayacak, yani foo() işlevi hiç çağrılmayacaktır.
$a = (false && foo());
$b = (true  || foo());
$c = (false and foo());
$d = (true  or  foo());

// --------------------
// "||" işlecinin önceliği "or" işlecinden yüksektir.
// İfadenin sonucu $e'ye atanır (false || true)
// Tıpkı şöyle: ($e = (false || true))
$e = false || true;

// "or" işleminden önce false sabiti $f'ye atanır ve true yoksayılır
// Tıpkı böyle: (($f = false) or true)
$f = false or true;

var_dump($e, $f);

// --------------------
// "&&" işlecinin önceliği "and" işlecinden yüksektir.
// İfadenin sonucu $g'ye atanır (true && false)
// Tıpkı böyle: ($g = (true && false))
$g = true && false;

// "and" işleminden önce true sabiti $h'ya atanır ve false yoksayılır
// Tıpkı böyle: (($h = true) and false)
$h = true and false;

var_dump($g, $h);
?>
]]>
    </programlisting>
    &example.outputs.similar;
    <screen>
<![CDATA[
bool(true)
bool(false)
bool(false)
bool(true)
]]>
    </screen>
   </example>
  </sect1>

  <sect1 xml:id="language.operators.string">
   <title>Dizge İşleçleri</title>
   <simpara>
    İki tane dizge işleci vardır. İlki sol ve sağ terimlerini ard arda
    ekleyen birleştirme işleci ('.'), ikincisi ise sağ taraftaki
    değiştirgeyi sol taraftaki değiştirgeye ekleyen birleştirerek atama
    işlecidir (<literal>.=</literal>). Daha fazla bilgi için <link
    linkend="language.operators.assignment">atama işleçleri</link> bölümüne
    bakınız.
   </simpara>

   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = "Merhaba ";
$b = $a . "Dünyalı!"; // $b artık "Merhaba Dünyalı!" içeriyor

$a = "Merhaba ";
$a .= "Dünyalı!";     // $a artık "Merhaba Dünyalı!" içeriyor
?>
]]>
     </programlisting>
    </informalexample>
   </para>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><link linkend="language.types.string"><type>string</type>
       türü</link></member>
      <member><link linkend="ref.strings">Dizge İşlevleri</link></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.array">
   <title>Dizi İşleçleri</title>
   <table>
    <title>Dizi İşleçleri</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Örnek</entry>
       <entry>İsim</entry>
       <entry>Sonuç</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><userinput>$a + $b</userinput></entry>
       <entry>Birleşim</entry>
       <entry><varname>$a</varname> ve <varname>$b</varname>'nin birleşimi.</entry>
      </row>
      <row>
       <entry><userinput>$a == $b</userinput></entry>
       <entry>Eşitlik</entry>
       <entry><varname>$a</varname> ve <varname>$b</varname> aynı anahtar/değer çiftlerine sahipse sonuç doğrudur.</entry>
      </row>
      <row>
       <entry><userinput>$a === $b</userinput></entry>
       <entry>Aynılık</entry>
       <entry><varname>$a</varname> ve <varname>$b</varname> aynı anahtar/değer çiftlerine sahipse ve bunların sırası ve türleri aynıysa sonuç doğrudur.</entry>
      </row>
      <row>
       <entry><userinput>$a != $b</userinput></entry>
       <entry>Eşitsizlik</entry>
       <entry><varname>$a</varname> ve <varname>$b</varname> birbirine eşit değilse sonuç doğrudur.</entry>
      </row>
      <row>
       <entry><userinput>$a &lt;&gt; $b</userinput></entry>
       <entry>Eşitsizlik</entry>
       <entry><varname>$a</varname> ve <varname>$b</varname> birbirine eşit değilse sonuç doğrudur.</entry>
      </row>
      <row>
       <entry><userinput>$a !== $b</userinput></entry>
       <entry>Farklılık</entry>
       <entry><varname>$a</varname> ve <varname>$b</varname> aynı dizi değilse sonuç doğrudur.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    <literal>+</literal> işleci sol taraf dizisini sağ taraf dizisine ekleyip sağ
    taraf dizisini döndürür. Her iki dizinin anahtarları alınır, sol taraf
    dizisinin elemenları alınır ve sağ taraf dizisindeki eşleşen elemanlar yok
    sayılır.
   </para>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("a" => "elma", "b" => "armut");
$b = array("a" => "vişne", "b" => "kiraz", "c" => "çilek");

$c = $a + $b;
echo "\$a ve \$b'nin birleşimi: \n";
var_dump($c);

$c = $b + $a;
echo "\$b ve \$a'nın birleşimi: \n";
var_dump($c);

$a += $b; // $a += $b'nin birleşimi $a ve $b'dir
echo "\$a += \$b'nin birleşimi: \n";
var_dump($a);
?>
]]>
     </programlisting>
    </informalexample>
    Betik çalıştırıldığında şu çıktıyı verir:
    <screen role="php">
<![CDATA[
$a ve $b'nin birleşimi:
array(3) {
  ["a"]=>
  string(4) "elma"
  ["b"]=>
  string(5) "armut"
  ["c"]=>
  string(6) "çilek"
}
$b ve $a'nın birleşimi:
array(3) {
  ["a"]=>
  string(6) "vişne"
  ["b"]=>
  string(5) "kiraz"
  ["c"]=>
  string(6) "çilek"
}
$a += $b'nin birleşimi:
array(3) {
  ["a"]=>
  string(5) "elma"
  ["b"]=>
  string(6) "muz"
  ["c"]=>
  string(6) "çilek"
}
]]>
    </screen>
   </para>
   <para>
    Aynı anahtar ve değere sahip dizi elemanları birbirine eşit kabul edilir.
   </para>
   <para>
    <example>
     <title>- Dizilerin karşılaştırılması</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = array("elma", "armut");
$b = array(1 => "armut", "0" => "elma");

var_dump($a == $b); // bool(true)
var_dump($a === $b); // bool(false)
?>
]]>
     </programlisting>
    </example>
   </para>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><link linkend="language.types.array"><type>array</type>
       türü</link></member>
      <member><link linkend="ref.array">Dizi İşlevleri</link></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="language.operators.type">
   <title>Tür İşleçleri</title>
   <para>
    <literal>instanceof</literal> işleci, bir PHP değişkeninin belli bir
    <link linkend="language.oop5.basic.class">sınıf</link>ın nesnel örneği
    olup olmadığını saptar:
    <example>
     <title>- <literal>instanceof</literal> ve sınıflar</title>
     <programlisting role="php">
<![CDATA[
<?php
class Sınıfım
{
}

class BaşkaSınıf
{
}
$a = new Sınıfım;

var_dump($a instanceof Sınıfım);
var_dump($a instanceof BaşkaSınıf);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(false)
]]>
     </screen>
    </example>
   </para>
   <para>
    <literal>instanceof</literal> ayrıca, bir değişkenin, bir ebeveyn
    sınıftan miras alınan bir sınıfın nesnel örneği olup olmadığını saptamak
    için de kullanılabilir:
    <example>
     <title>- Miras alınan sınıflar ve <literal>instanceof</literal> kullanımı
     </title>
     <programlisting role="php">
<![CDATA[
<?php
class EbeveynSınıf
{
}

class Sınıfım extends EbeveynSınıf
{
}

$a = new Sınıfım;

var_dump($a instanceof Sınıfım);
var_dump($a instanceof EbeveynSınıf);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    Bir nesne bir sınıfın örneği değilse bunu sınamak için  <link
    linkend="language.operators.logical">mantıksal değil işleci</link>
    kullanılabilir.
    <example>
     <title>- Bir sınıfın örneği olmayan bir sınıfın
       <literal>instanceof</literal> ile sınanması</title>
     <programlisting role="php">
<![CDATA[
<?php
class Sınıfım
{
}

$a = new Sınıfım;
var_dump(!($a instanceof stdClass));
?>
]]>
     </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    Son olarak, <literal>instanceof</literal> işleci, bir değişkenin, bir <link
    linkend="language.oop5.interfaces">arayüz</link>ü gerçekleyen bir
    sınıfın örneği olup olmadığını sınamak için kullanılabilir:
    <example>
     <title>- Arayüzler için <literal>instanceof</literal> kullanımı</title>
     <programlisting role="php">
<![CDATA[
<?php
interface Arayüzüm
{
}

class Sınıfım implements Arayüzüm
{
}

$a = new Sınıfım;

var_dump($a instanceof Sınıfım);
var_dump($a instanceof Arayüzüm);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
bool(true)
bool(true)
]]>
     </screen>
    </example>
   </para>
   <para>
    <literal>instanceof</literal> işlecinin normal olarak bir sayıl sınıf ismi ile
    kullanılmasının yanında başka bir nesne veya bir dizge değişkeni ile de
    kullanılabilir:
    <example>
     <title>- Başka değişkenlerle <literal>instanceof</literal> kullanımı</title>
     <programlisting role="php">
<![CDATA[
<?php
interface Arayüzüm
{
}

class Sınıfım implements Arayüzüm
{
}

$a = new Sınıfım;
$b = new Sınıfım;
$c = 'Sınıfım';
$d = 'BaşkaSınıf';

var_dump($a instanceof $b); // $b, Sınıfım sınıfının bir nesnesidir
var_dump($a instanceof $c); // $c 'Sınıfım' dizgesini içerir
var_dump($a instanceof $d); // $d 'BaşkaSınıf' dizgesini içerir
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(true)
bool(true)
bool(false)
]]>
     </screen>
    </example>
   </para>
   <para>
    Sınanan değişken bir nesne değilse instanceof hata çıktılamaz, basitçe
    &false; döndürür. Sabitlere, her nasılsa, PHP 7.3.0 öncesinde izin
    verilmezdi.
    <example>
     <title>- Değişkenleri sınamak için <literal>instanceof</literal> kullanımı</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 1;
$b = NULL;
$c = imagecreate(5, 5);
var_dump($a instanceof stdClass); // $a bir tamsayıdır
var_dump($b instanceof stdClass); // $b NULL'dur
var_dump($c instanceof stdClass); // $c bir özkaynaktır
var_dump(FALSE instanceof stdClass);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(false)
bool(false)
bool(false)
PHP Fatal error:  instanceof expects an object instance, constant given
]]>
     </screen>
    </example>
   </para>
   <para>
    PHP 7.3.0 ve sonrasında, <literal>instanceof</literal> işlecinin sol
    tarafında sabitlere izin verilmektedir.
    <example>
     <title>- Sabit kullanımını sınamak için <literal>instanceof</literal> kullanımı</title>
     <programlisting role="php">
<![CDATA[
<?php
var_dump(FALSE instanceof stdClass);
?>
]]>
    </programlisting>
    &example.outputs.73;
    <screen>
<![CDATA[
bool(false)
]]>
     </screen>
    </example>
   </para>
   <para>
    PHP 8.0.0 ve sonrasında, <literal>instanceof</literal> keyfi ifadelerde
    kullanılabilmektedir. Bu ifadeler parantezlerle sarmalanmalı
    ve bir dizge üretmelidir.
    <!-- RFC: https://wiki.php.net/rfc/variable_syntax_tweaks -->
    <example>
     <title>- Keyfi ifadelerde <literal>instanceof</literal> kullanımı</title>
     <programlisting role="php">
      <![CDATA[
<?php

class ClassA extends \stdClass {}
class ClassB extends \stdClass {}
class ClassC extends ClassB {}
class ClassD extends ClassA {}

function getSomeClass(): string
{
    return ClassA::class;
}

var_dump(new ClassA instanceof ('std' . 'Class'));
var_dump(new ClassB instanceof ('Class' . 'B'));
var_dump(new ClassC instanceof ('Class' . 'A'));
var_dump(new ClassD instanceof (getSomeClass()));
?>
]]>
     </programlisting>
     &example.outputs.8;
     <screen>
      <![CDATA[
bool(true)
bool(true)
bool(false)
bool(true)
]]>
     </screen>
    </example>
   </para>
   <simpara>
    <literal>instanceof</literal> işleci yerine kullanılabilecek
    bir işlev de vardır: <function>is_a</function>
   </simpara>

   <sect2 role="seealso">
    &reftitle.seealso;
    <para>
     <simplelist>
      <member><function>get_class</function></member>
      <member><function>is_a</function></member>
     </simplelist>
    </para>
   </sect2>
  </sect1>
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
