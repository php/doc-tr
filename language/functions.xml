<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 82d79c66531b3a08b781ac8c89c0c2f2fe4efb8f Maintainer: nilgun Status: ready -->
<!-- CREDITS: tpug, sezer -->
 <chapter xml:id="language.functions" xmlns="http://docbook.org/ns/docbook">
  <title>İşlevler</title>

  <sect1 xml:id="functions.user-defined">
   <title>Kullanıcı tanımlı işlevler</title>

   <para>
    Bir işlev, şöyle bir söz dizimi kullanılarak tanımlanabilir:
   </para>
   <para>
    <example>
     <title>- İşlev kullanımını gösteren sözde kod</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo($arg_1, $arg_2, /* ..., */ $arg_n)
{
    echo "Örnek işlev.\n";
    return $retval;
}
?>
]]>
     </programlisting>
    </example>
   </para>

   <simpara>
    Bir işlevin içerisinde geçerli her tür PHP kodu kullanılabilir, buna
    başka işlevler ve <link linkend="language.oop5.basic.class">sınıf</link> 
    tanımları da dahildir.
   </simpara>
   <para>
    İşlev isimleri, PHP'deki diğer isimlerle aynı kurallara tabidir. Geçerli
    bir işlev ismi bir harf ya da alt çizgi ile başlar, herhangi bir sayıda
    geçerli harf, sayı ya da alt çizgi ile devam eder. Düzenli ifade olarak,
    şu şekilde ifade edebiliriz:
   <literal>[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*</literal>.
   </para>
   <simpara>
    İşlevlerin çağrılmadan önce tanımlanmaları, aşağıdaki iki örnekte
    görüldüğü gibi koşullu olarak tanımlandıkları durumlar haricinde gerekmez.
   </simpara>
   <para>
    Bir işlev aşağıdaki iki örnekte gösterildiği gibi koşullu olarak
    tanımlandıysa, bu işlev tanımının işlev çağrılmadan <emphasis>önce</emphasis> yapılması gerekmektedir.
   </para>
   <para>
    <example>
     <title>- Koşula bağlı işlevler</title>
     <programlisting role="php">
<![CDATA[
<?php

$makefoo = true;

/* Henüz varolmadığı için foo() buradan çağrılamaz,
   ancak bar() çağrılabilir */

bar();

if ($makefoo) {
  function foo()
  {
    echo "Uygulamanın çalışması bana erişene kadar ben yokum.\n";
  }
}

/* $makefoo doğru olduğundan
   artık foo() çağrılabilir */

if ($makefoo) foo();

function bar()
{
  echo "Program başlatıldığı anda ben de varolurum.\n";
}

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>- İşlev içinde işlev</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo()
{
  function bar()
  {
    echo "foo() çağrılana kadar yokum.\n";
  }
}

/* Henüz varolmadığı için
   bar() çağrılamaz. */

foo();

/* Artık bar() çağrılabilir,
   foo() çağrıldığında bar()
   erişilebilir hale gelir */

bar();

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    PHP'de tüm işlevler ve sınıflar betik genelinde geçerlidir - bir işlevin
    içinden bile tanımlanmış olsalar işlevin dışından çağrılabilirler.
   </para>
   <simpara>
    PHP işlevlerin farklı değiştirgeli yeni tanımlarının yapılmasını
    desteklemediği gibi, işlevler yeniden tanımlanamaz veya tanımsız
    kılınamaz.
   </simpara>
   <note>
    <simpara>
      İşlev isimleri büyük-küçük harf duyarsızdır, ancak işlev isimlerini
      tanımlandıkları halleriyle kullanmak daha iyidir.
    </simpara>
   </note>
   <simpara>
    <link linkend="functions.variable-arg-list">Değiştirge sayısı değişken
    işlevler</link> desteklendiği gibi işlevlerde <link
    linkend="functions.arguments.default">öntanımlı değiştirge</link>
    kullanımı da desteklenmektedir. Daha ayrıntılı bilgi edinmek için
    <function>func_num_args</function>, <function>func_get_arg</function> ve
    <function>func_get_args</function> işlevlerine de bakınız.
   </simpara>

   <para>
    PHP'de işlevlerin kendilerini çağırması da mümkündür.
    <example>
     <title>- Kendini çağıran işlev</title>
     <programlisting role="php">
<![CDATA[
<?php
function recursion($a)
{
    if ($a < 20) {
        echo "$a\n";
        recursion($a + 1);
    }
}
?>
]]>
     </programlisting>
    </example>
   <note>
    <simpara>
     Kendini çağıran işlev ve yöntemler bunu 100-200 kere yaparsa yığıt
     taşabilir ve çalışan betiğin durdurulmasına sebep olabilir. Özellikle,
     kendini çağırma sayısı sonsuza giderse bu bir programlama hatası sayılır.
    </simpara>
   </note>
   </para>

  </sect1>

  <sect1 xml:id="functions.arguments">
   <title>İşlev değiştirgeleri</title>

   <simpara>
    Bir işleve veri, virgül ayraçlı ifadelerden oluşan bir değiştirge listesi
    ile aktarılır. Değitirgeler soldan sağa doğru değerlendirilir.
   </simpara>
   <para>
    PHP, değiştirgelerin değerleriyle aktarılmalarını (öntanımlı), <link
    linkend="functions.arguments.by-reference">gönderimli aktarım</link>ı ve
    <link linkend="functions.arguments.default">öntanımlı değiştirge
    kullanımı</link>nı destekler. <link
    linkend="functions.variable-arg-list">Değiştirge sayısı değişken
    işlevler</link> de desteklenmektedir.
   </para>
   <para>
    <example>
     <title>- İşlevlere dizi aktarımı</title>
     <programlisting role="php">
<![CDATA[
<?php
function dizi_kabul_eder($girdi)
{
    echo "$girde[0] + $girdi[1] = ", $girdi[0]+$girdi[1];
}
?>
]]>
     </programlisting>
    </example>
   </para>

   <sect2 xml:id="functions.arguments.by-reference">
    <title>Gönderimli değiştirge kullanımı</title>

    <simpara>
      Öntanımlı olarak, işlev değiştirgeleri değerleriyle aktarılırlar (bu
      durumda bir değiştirgenin değeri işlev içinde değiştirildiğinde işlevin
      çağrıldığı yerdeki değeri bundan etkilenmez. İşlevin çağrıldığı yerdeki
      değerinin de değişmesini istiyorsanız gönderimli değiştirge
      kullanmalısınız.
    </simpara>
    <para>
      Bir işleve bir değiştirgenin daima gönderimli olarak aktarılmasını
      istiyorsanız, işlev tanımladığınız yerde o değiştirgenin başına &amp;
      karakterini koyarak bunu sağlayabilirsiniz:
    </para>
    <para>
     <example>
      <title>- Gönderimli işlev değiştirgelerinin aktarımı</title>
      <programlisting role="php">
<![CDATA[
<?php
function şunu_da_ekle(&$dizge)
{
    $dizge .= 've bir kaç karakter eklenmiştir.';
}
$dzg = 'Bu bir dizgedir ';
şunu_da_ekle($dzg);
echo $dzg;    // 'Bu bir dizgedir ve bir kaç karakter eklenmiştir.'
              //  çıktısını verir.
?>
]]>
      </programlisting>
     </example>
    </para>

   </sect2>

   <sect2 xml:id="functions.arguments.default">
    <title>Öntanımlı değiştirge değerleri</title>

    <para>
      Bir işlevde, sayıl değiştirgeler için C++ tarzı öntanımlı değerler
      aşağıdaki biçimde tanımlanabilir:
    </para>
    <para>
     <example>
      <title>- İşlev içinde öntanımlı değiştirge kullanımı</title>
      <programlisting role="php">
<![CDATA[
<?php
function kahveyap($hangisi = "orta şekerli")
{
    return "Bir fincan $hangisi kahve yapalım.\n";
}
echo kahveyap();
echo makecoffee(null);
echo kahveyap("az şekerli");
?>
]]>
      </programlisting>
      &example.outputs;
     <screen>
<![CDATA[
Bir fincan orta şekerli kahve yapalım.
Bir fincan kahve yapalım.
Bir fincan az şekerli kahve yapalım.
]]>
      </screen>
     </example>
    </para>
    <para>
      PHP ayrıca, öntanımlı değer olarak dizilerin ve özel &null; türünün
      kullanımına da izin verir, örneğin:
    </para>
    <para>
     <example>
      <title>- Sayıl olmayan türlerin öntanımlı değer olarak kullanımı</title>
      <programlisting role="php">
<![CDATA[
<?php
function kahveyap($hangi = array("orta şekerli"), $neyde = NULL)
{
    $neyde = is_null($neyde) ? "ocakta" : $neyde;
    return "Bir fincan ".join(" bir fincan ", $hangi)." kahve $neyde yapıldı.\n";
}
echo kahveyap();
echo kahveyap(array("çok şekerli", "az şekerli"), "mangalda");
?>
]]>
      </programlisting>
     </example>

    </para>
    <simpara>
      Öntanımlı değer bir değişken, bir sınıf üyesi ya da bir işlev çağrısı
      değil, bir sabit ifadesi olmalıdır.
    </simpara>
    <para>
      Öntanımlı değiştirgeleri kullanırken, öntanımlama yapılmış tüm
      değiştirgelerin öntanımlama yapılmamış tüm değiştirgelerin sağında yer
      almasına gerektiğine dikkat edin. Aksi takdirde işler yolunda
      gitmeyebilir. Aşağıdaki kod parçasını inceleyin:
    </para>
    <para>
     <example>
      <title>- Öntanımlı değiştirgelerin hatalı kullanımı</title>
      <programlisting role="php">
<![CDATA[
<?php
function yoğurtyap($nekadar = "az", $neli)
{
    return "Bir kase $nekadar $neli yoğurt yap.\n";
}

echo yoğurtyap("çilekli");   // beklendiği gibi çalışmayacaktır
?>
]]>
      </programlisting>
      &example.outputs;
     <screen>
<![CDATA[
Warning: Missing argument 2 for yoğurtyap(), called in
/home/nilgun/dnm/php-dnm on line 7 and defined in
/home/nilgun/dnm/php-dnm on line 2
Bir kase çilekli  yoğurt yap.
]]>
      </screen>
     </example>
    </para>
    <para>
      Şimdi, yukarıdakini bununla karşılaştıralım:
    </para>
    <para>
     <example>
      <title>- Öntanımlı değiştirgelerin doğru kullanımı</title>
      <programlisting role="php">
<![CDATA[
<?php
function yoğurtyap($neli, $nekadar= "az")
{
    return "Bir kase $nekadar $neli yoğurt yap.\n";
}

echo yoğurtyap("çilekli");   // beklendiği gibi çalışır
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Bir kase az çilekli yoğurt yap.
]]>
      </screen>
     </example>
    </para>

    <note>
     <simpara>
     PHP 5'den itibaren, gönderimli aktarılabilen değiştirgeler öntanımlı değer
     içerebilmektedir.
     </simpara>
    </note>
   </sect2>

   <sect2 xml:id="functions.arguments.type-declaration">
    <title>Tür Bildirimleri</title>

    <note>
     <para>
      Tür bildirimleri PHP 5'de tür önerileri olarak da bilinir.
     </para>
    </note>

    <para>
     Tür bildirimleri işlevlerin çalıştırılması sırasında belli bir tür
     gerektirmesini sağlar. Eğer değer uygun olmayan bir türdeyse PHP 5'de
     kurtarılabilir bir ölümcül hata oluşurken, PHP 7'de
     <classname>TypeError</classname> istisnası oluşur.
    </para>

    <para>
     Tür bildirimini belirtmek için, tür ismi değiştirge isminden önce
     gelmelidir. Değiştirgenin öntanımlı değeri &null; olacaksa bildirim &null;
     kabul edecek şekilde yapılabilir.
    </para>

    <sect3 xml:id="functions.arguments.type-declaration.types">
     <title>Geçerli türler</title>
     <informaltable>
      <tgroup cols="3">
       <thead>
        <row>
         <entry>Tür</entry>
         <entry>Açıklama</entry>
         <entry>Minimum PHP sürümü</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>Sınıf/arayüz ismi</entry>
         <entry>
          Tür olarak bir sınıf veya arayüz ismi belirtilmişse değiştirge bir
          &instanceof; olmalıdır.
         </entry>
         <entry>PHP 5.0.0</entry>
        </row>
        <row>
         <entry><literal>self</literal></entry>
         <entry>
          Tür, yöntemin tanımlandığı sınıf olarak belirtilirse değiştirge bir
          &instanceof; olmalıdır. Bu sadece sınıfın veya örneğinin
          yöntemlerinde kullanılabilir.
         </entry>
         <entry>PHP 5.0.0</entry>
        </row>
        <row>
         <entry><type>array</type></entry>
         <entry>
          Değiştirge geçerli bir dizi olmalıdır.
         </entry>
         <entry>PHP 5.1.0</entry>
        </row>
        <row>
         <entry><type>callable</type></entry>
         <entry>
          Değiştirge geçerli bir işlev olmalıdır.
         </entry>
         <entry>PHP 5.4.0</entry>
        </row>
        <row>
         <entry><type>bool</type></entry>
         <entry>
          Değiştirge geçerli bir mantıksal değer olmalıdır.
         </entry>
         <entry>PHP 7.0.0</entry>
        </row>
        <row>
         <entry><type>float</type></entry>
         <entry>
          Değiştirge geçerli bir gerçel değer olmalıdır.
         </entry>
         <entry>PHP 7.0.0</entry>
        </row>
        <row>
         <entry><type>int</type></entry>
         <entry>
          Değiştirge geçerli bir tamsayı olmalıdır.
         </entry>
         <entry>PHP 7.0.0</entry>
        </row>
        <row>
         <entry><type>string</type></entry>
         <entry>
          Değiştirge geçerli bir dizge olmalıdır.
         </entry>
         <entry>PHP 7.0.0</entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
     <warning>
      <para>
       Yukarıdaki türler için takma ad kullanımı desteklenmemektedir.
       Ancak, bunlar bir sınıf veya arayüz adı olarak ele alınabilir.
       Örneğin, <literal>boolean</literal> türünün <type>bool</type> türü 
       yerine, bir değiştirge gerektiren bir dönüş türü veya &instanceof; 
       sınıfı bir dönüş değeri veya <literal>boolean</literal> arayüzü veya 
       bir değiştirge olarak kullanımı:
      </para>
      <para>
       <example>
        <programlisting role="php">
 <![CDATA[
 <?php
 function test(boolean $param) {}
 test(true);
 ?>
 ]]>
        </programlisting>
        &example.outputs;
        <screen>
 <![CDATA[
 Fatal error: Uncaught TypeError: Argument 1 passed to test() must be an instance of boolean, boolean given, called in - on line 1 and defined in -:1
 ]]>
        </screen>
       </example>
      </para>
     </warning>
    </sect3>

    <sect3 xml:id="functions.arguments.type-declaration.examples">
     &reftitle.examples;
     <example>
      <title>Temel sınıf türü bildirimi</title>
      <programlisting role="php">
<![CDATA[
<?php
class C {}
class D extends C {}

// Bu C sınıfını örnek almıyor.
class E {}

function f(C $c) {
    echo get_class($c)."\n";
}

f(new C);
f(new D);
f(new E);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
C
D

Fatal error: Uncaught TypeError: Argument 1 passed to f() must be an instance of C, instance of E given, called in - on line 14 and defined in -:8
Stack trace:
#0 -(14): f(Object(E))
#1 {main}
  thrown in - on line 8
]]>
      </screen>
     </example>

     <example>
      <title>Temel arayüz türü bildirimi</title>
      <programlisting role="php">
<![CDATA[
<?php
interface I { public function f(); }
class C implements I { public function f() {} }

// Bu I'yi gerçeklemez.
class E {}

function f(I $i) {
    echo get_class($i)."\n";
}

f(new C);
f(new E);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
C

Fatal error: Uncaught TypeError: Argument 1 passed to f() must implement interface I, instance of E given, called in - on line 13 and defined in -:8
Stack trace:
#0 -(13): f(Object(E))
#1 {main}
  thrown in - on line 8
]]>
      </screen>
     </example>

     <example>
      <title>Boş olabilen tür bildirimi</title>
      <programlisting role="php">
<![CDATA[
<?php
class C {}

function f(C $c = null) {
    var_dump($c);
}

f(new C);
f(null);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
object(C)#1 (0) {
}
NULL
]]>
      </screen>
     </example>
    </sect3>

    <sect3 xml:id="functions.arguments.type-declaration.strict">
     <title>Kesin tür belirtimi</title>

     <para>
      Öntanımlı olarak PHP yanlış türde belirtilmiş değerleri eğer mümkünse
      bilinen bir türe zorlar. Örneğin, bir işleve <type>string</type> türünde
      beklenirken <type>integer</type> türünde bir değer belirtilmişse
      <type>string</type> türünde bir değişken elde edilir.
     </para>

     <para>
      Dosyaya özel olmak kaydıyla kesin kipi etkin kılmak mümkündür. Kesin kipte sadece tür belirtiminde belirtilmiş türde bir değer kabul edilir, aksi takdirde bir <classname>TypeError</classname> istisnası oluşur. Bu kuralın tek istisnası, <type>float</type> türünde bir değer beklenen bir işleve <type>integer</type> türünde bir değer belirtilebilmesidir. Dahili işlevlerin içinden yapılan işlev çağrıları kesin tür belirtiminden etkilenmez.
     </para>

     <para>
      Kesin kipi etkin kılmak için &declare; deyimi
      <literal>strict_types</literal> bildirimi ile birlikte kullanılır:
     </para>

     <caution>
      <para>
       Kesin kipi etkin kılmak ayrıca
       <link linkend="functions.returning-values.type-declaration">dönen tür
       bildirimlerini</link> de etkiler.
      </para>
     </caution>

     <note>
      <para>
       Kesin kipin uygulanabilmesi için işlev tanımlarının işlev çağrısının
       yapıldığı kesin kipli dosyada bulunması gerekmez. Ancak kesin kipli
       olmayan bir dosyadan yapılan bir işlev çağrısı kesin kipli dosyada
       tanımlı bir işlevi çağırıyorsa çağrıcının tercihine (zayıf tür) uyulur
       ve değer zorlanabilir.
      </para>
     </note>

     <note>
      <para>
       Kesin tür sadece sayısal tür bildirimlerine uygulanır dolayısıyla bunun
       için PHP 7.0.0 ve sonrası gerekir. Bunun sebebi sayısal tür
       bildirimlerinin bu sürümde eklenmiş olmasıdır.
      </para>
     </note>

     <example>
      <title>Kesin tür örneği</title>
      <programlisting role="php">
<![CDATA[
<?php
declare(strict_types=1);

function sum(int $a, int $b) {
    return $a + $b;
}

var_dump(sum(1, 2));
var_dump(sum(1.5, 2.5));
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
int(3)

Fatal error: Uncaught TypeError: Argument 1 passed to sum() must be of the type integer, float given, called in - on line 9 and defined in -:4
Stack trace:
#0 -(9): sum(1.5, 2.5)
#1 {main}
  thrown in - on line 4
]]>
      </screen>
     </example>

     <example>
      <title>Zayıf tür örneği</title>
      <programlisting role="php">
<![CDATA[
<?php
function sum(int $a, int $b) {
    return $a + $b;
}

var_dump(sum(1, 2));

// bunlar tamsayıya zorlanacaktır; aşağıdaki çıktıya bakın!
var_dump(sum(1.5, 2.5));
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
int(3)
int(3)
]]>
      </screen>
     </example>

     <example>
      <title><classname>TypeError</classname> yakalama</title>
      <programlisting role="php">
<![CDATA[
<?php
declare(strict_types=1);

function sum(int $a, int $b) {
    return $a + $b;
}

try {
    var_dump(sum(1, 2));
    var_dump(sum(1.5, 2.5));
} catch (TypeError $e) {
    echo 'Error: '.$e->getMessage();
}
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
int(3)
Error: Argument 1 passed to sum() must be of the type integer, float given, called in - on line 10
]]>
      </screen>
     </example>
    </sect3>
    </sect2>

   <sect2 xml:id="functions.variable-arg-list">
    <title>Değiştirge sayısı değişken işlevler</title>

    <simpara>
      Değiştirge sayısı değişken kullanıcı tanımlı işlevler desteklenmektedir.
      PHP 5.6 ve sonrasında bu <literal>...</literal> ile, PHP 5.5 ve öncesinde
      ise <function>func_num_args</function>,
      <function>func_get_arg</function> ve <function>func_get_args</function>
      işlevleri sayesinde bu özelliği kolayca kullanabilirsiniz.
    </simpara>

    <sect3 xml:id="functions.variable-arg-list.new">
     <title>PHP 5.6 ve sonrasında <literal>...</literal></title>

     <para>
      PHP 5.6 ve sonrasında, işlevin değişken sayıda değiştirge içerebilmesini sağlamak için değiştirge listesine <literal>...</literal> dizgeciği konulabilir. Değiştirgeler belirtilen değikene bir dizi olarak aktarılır.
      Örnek:

      <example>
       <title>Değişkenin değiştirgelerine erişim için <literal>...</literal>
         kullanımı</title>
       <programlisting role="php">
<![CDATA[
<?php
function sum(...$numbers) {
    $acc = 0;
    foreach ($numbers as $n) {
        $acc += $n;
    }
    return $acc;
}

echo sum(1, 2, 3, 4);
?>
]]>
       </programlisting>
       &example.outputs;
       <screen>
<![CDATA[
10
]]>
       </screen>
      </example>
     </para>

     <para>
      Bir diziyi, bir <classname>Traversable</classname> değişkeni veya bir sabiti değiştirge listesi haline getirmek için işlev çağrılırken de <literal>...</literal> kullanılabilir. Örnek:

      <example>
        <title> Değiştirgelere erişmek için <literal>...</literal>
        kullanımı</title>
       <programlisting role="php">
<![CDATA[
<?php
function add($a, $b) {
    return $a + $b;
}

echo add(...[1, 2])."\n";

$a = [1, 2];
echo add(...$a);
?>
]]>
       </programlisting>
       &example.outputs;
       <screen>
<![CDATA[
3
3
]]>
       </screen>
      </example>
     </para>

     <para>
      <literal>...</literal> dizgeciğinden önce normal konumsal değiştirgeler
      belirtilebilir. Bu durumda <literal>...</literal> ile üretilen diziye
      sadece bir konumsal değiştirge ile eşleşmeyen tokeni izleyen değiştirgeler
      eklenir.
     </para>

     <para>
      <literal>...</literal> dizgeciğinin önüne bir
      <link linkend="language.oop5.typehinting">tür dayatıcı</link> eklemek de
      mümkündür. Böyle bir durumda, <literal>...</literal> tarafından işleme
      sokulacak tüm değiştirgeler dayatılan sınıfın nesneleri olmalıdır

      <example>
       <title>Değişken değiştirgelerinde tür dayatma</title>
       <programlisting role="php">
<![CDATA[
<?php
function total_intervals($unit, DateInterval ...$intervals) {
    $time = 0;
    foreach ($intervals as $interval) {
        $time += $interval->$unit;
    }
    return $time;
}

$a = new DateInterval('P1D');
$b = new DateInterval('P2D');
echo total_intervals('d', $a, $b).' gün';

// Bir DateInterval nesnesi olmadığından bu başarısız olur.
echo total_intervals('d', null);
?>
]]>
       </programlisting>
       &example.outputs;
       <screen>
<![CDATA[
3 gün
Catchable fatal error: Argument 2 passed to total_intervals() must be an instance of DateInterval, null given, called in - on line 14 and defined in - on line 2
]]>
       </screen>
      </example>
     </para>

     <para>
      Son olarak, <literal>...</literal> dizgeciğinin önüne bir
       <literal>&amp;</literal> ekleyerek değişken değiştirgelerini
       <link linkend="functions.arguments.by-reference">gönderimli</link>
       olarak da aktarabilirsiniz.
     </para>
    </sect3>

    <sect3 xml:id="functions.variable-arg-list.old">
     <title>Daha eski PHP sürümlerinde</title>

     <para>
      Bir işlevin değişken sayıda değiştirge içerebilmesi özel bir sözdizimi
      gerekmez; ancak işlevin değiştirgelerine erişim için
      <function>func_num_args</function>, <function>func_get_arg</function>
      ve <function>func_get_args</function> kullanmak gerekir.
     </para>

     <para>
      PHP 5.5 ve öncesinde yukarıdaki ilk örnek şöyle gerçeklenirdi;

      <example>
       <title>PHP 5.5 ve öncesinde değişken değiştirgelerine erişim</title>
       <programlisting role="php">
<![CDATA[
<?php
function sum() {
    $acc = 0;
    foreach (func_get_args() as $n) {
        $acc += $n;
    }
    return $acc;
}

echo sum(1, 2, 3, 4);
?>
]]>
       </programlisting>
       &example.outputs;
       <screen>
<![CDATA[
10
]]>
       </screen>
      </example>
     </para>
    </sect3>
   </sect2>
  </sect1>

  <sect1 xml:id="functions.returning-values">
   <title>Dönen değerler</title>

   <para>
    Değerler, kullanımı seçime bağlı olan <command>return</command> deyimi
    kullanılarak döndürülür. Her türde değer döndürülebilir, buna diziler ve
    nesneler dahildir. <function>return</function> kullanıldığında işlevin
    çalışması o noktada hemen durdurulur ve denetim işlevin çağrıldığı satıra
    aktarılır. Daha ayrıntılı bilgi için <function>return</function> bölümüne
    bakınız.
   </para>
   <note>
    <para>
     <function>return</function> belirtilmezse &null; değeri döner.
    </para>
   </note>

   <sect2>
    <title><code>return</code> kullanımı</title>
    <para>
     <example>
      <title>- <code>return</code> kullanımı</title>
      <programlisting role="php">
<![CDATA[
<?php
function square($num)
{
    return $num * $num;
}
echo square(4);   // '16' çıktılar.
?>
]]>
     </programlisting>
    </example>
   </para>

   <para>
    Bir işlevden birden fazla değer döndüremezsiniz, ancak böyle bir sonucu
    bir dizi döndürülerek elde edebilirsiniz.
   </para>
   <para>
    <example>
     <title>- Bir diziyle birden fazla değerin döndürülmesi</title>
     <programlisting role="php">
<![CDATA[
<?php
function küçük_sayılar()
{
    return array (0, 1, 2);
}
list ($sıfır, $bir, $iki) = küçük_sayılar();
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Bir işlevden gönderimli bir değer döndürmek için, &amp; işlecini hem
    işlev bildiriminde hem de dönen değeri bir değişkene atarken
    kullanmalısınız:
   </para>
   <para>
    <example>
     <title>- Bir işlevden gönderimli değer döndürmek</title>
     <programlisting role="php">
<![CDATA[
<?php
function &gönderimli_döndür()
{
    return $gönderim;
}

$yenigönderim =& gönderimli_döndür();
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Gönderimler hakkında daha fazla bilgi edinmek için <link
    linkend="language.references">Gönderimler Hakkında</link> bölümüne
    bakınız.
   </simpara>
  </sect2>

  <sect2 xml:id="functions.returning-values.type-declaration">
   <title>Dönen tür bildirimleri</title>

   <para>
    PHP 7'de dönen tür bildirimleri desteği eklenmiştir.
    <link linkend="functions.arguments.type-declaration">Değiştirge türünde
    bildirimlere</link> benzer şekilde, dönen tür bildirimlerinde değerin
    türünü bir işlevden dönen değerin türü belirler. Dönen tür belirtimlerinde
    kullanılabilen türler
    <link linkend="functions.arguments.type-declaration.types">değiştirge türü
    bildirimlerdeki türlerle</link> aynıdır.
   </para>

   <para>
    <link linkend="functions.arguments.type-declaration.strict">Kesin tür
    belirtimi</link> dönen tür belirtimlerini de etkiler. Öntanımlı zayıf
    kipte, dönen türler istenen türde değilse doğru türe zorlanır. Kesin tipte
    ise dönen değer doğru türde değilse <classname>TypeError</classname>
    istisnası oluşur.
   </para>

   <note>
    <para>
     Bir ebeveyn yöntem geçersizleştirilirken çocuğun yönteminin ebeveyn
     üstündeki dönen tür bildirimiyle eşleşmesi gerekir. Eğer ebeveyn bir dönen
     tür tanımlamıyorsa çocuğun yöntemi de öyle yapabilir.
    </para>
   </note>

   <sect3 xml:id="functions.returning-values.type-declaration.examples">
    &reftitle.examples;

    <example>
     <title>Temel dönen tür bildirimi</title>
     <programlisting role="php">
<![CDATA[
<?php
function sum($a, $b): float {
    return $a + $b;
}

// float döneceğini unutmayın.
var_dump(sum(1, 2));
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
float(3)
]]>
      </screen>
     </example>

     <example>
      <title>Kesin kip işe karışırsa</title>
      <programlisting role="php">
<![CDATA[
<?php
declare(strict_types=1);

function sum($a, $b): int {
    return $a + $b;
}

var_dump(sum(1, 2));
var_dump(sum(1, 2.5));
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
int(3)

Fatal error: Uncaught TypeError: Return value of sum() must be of the type integer, float returned in - on line 5 in -:5
Stack trace:
#0 -(9): sum(1, 2.5)
#1 {main}
  thrown in - on line 5
]]>
      </screen>
     </example>

     <example>
      <title>Bir nesne döndürmek</title>
      <programlisting role="php">
<![CDATA[
<?php
class C {}

function getC(): C {
    return new C;
}

var_dump(getC());
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
object(C)#1 (0) {
}
]]>
      </screen>
     </example>
    </sect3>
   </sect2>
  </sect1>

  <sect1 xml:id="functions.variable-functions">
   <title>Değişken işlevler</title>

   <para>
    PHP değişken işlev kavramını desteklemektedir. Yani, bir değişken isminin
    sonuna parantez eklenmişse, PHP aynı isimde bir işlev olup olmadığına
    bakar ve bulduğu takdirde bu işlevi çalıştırmaya çalışır. Başka olası
    işlemlerin yanında, bu özellik geri çağırımların, işlev tablolarının ve
    benzerlerinin gerçeklenmesinde kullanılabilir.
   </para>
   <para>
    Değişken işlevler,
    <function>echo</function>, <function>print</function>,
    <function>unset</function>, <function>isset</function>,
    <function>empty</function>, <function>include</function>,
    <function>require</function> ve benzeri dil yapılarında çalışmayacaktır.
    Bu yapıları değişken işlev olarak kullanmak istediğiniz takdirde, gerekli
    sarmalayıcı işlevleri kendiniz yazmalısınız.
   </para>
   <para>
    <example>
     <title>- Değişken işlev örneği</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo() {
    echo "In foo()<br />\n";
}

function bar($arg = '')
{
    echo "In bar(); argument was '$arg'.<br />\n";
}

// Bu echo için sarmalayıcı işlevdir
function echoit($string)
{
    echo $string;
}

$func = 'foo';
$func();        // foo() çağrılır

$func = 'bar';
$func('test');  // bar() çağrılır

$func = 'echoit';
$func('test');  // echoit() çağrılır
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Değişken işlev özelliğini kullanarak bir nesnenin bir yöntemini de
    çağırabilmeniz mümkündür.
    <example>
     <title>- Değişken yöntem örneği</title>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    function Variable()
    {
        $name = 'Bar';
        $this->$name(); // Bu Bar() yöntemini çağıracaktır
    }

    function Bar()
    {
        echo "Bu bir Bar";
    }
}

$foo = new Foo();
$funcname = "Variable";
$foo->$funcname();  // Bu $foo->Variable() işlevini çağıracaktır

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Static türünden yöntemleri çağırırken işlev çağrısı 'static property' işlecinden daha güçlüdür:
    <example>
     <title>Duruk özellikli yöntem çağrısı örneği</title>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    static $variable = 'static property';
    static function Variable()
    {
        echo 'Method Variable called';
    }
}

echo Foo::$variable; // Bu 'static property' basar. Bu bağlamda $variable gerekmez.
$variable = "Variable";
Foo::$variable();  // Bu bağlamda $variable değişkenini okuyan $foo->Variable() çağrılır.

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
     PHP 5.4.0'dan itibaren bir değişkene saklanmış <type>callable</type> türünde bir işlevi çağırabilirsiniz.
    <example>
     <title>Karmaşık çağrılar</title>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    static function bar()
    {
        echo "bar\n";
    }
    function baz()
    {
        echo "baz\n";
    }
}

$func = array("Foo", "bar");
$func(); // prints "bar"
$func = array(new Foo, "baz");
$func(); // prints "baz"
$func = "Foo::bar";;
$func(); // PHP 7.0.0 öncesinde "bar" basar ve ölümcül hata üretirdi
?>
]]>
     </programlisting>
    </example>
   </para>
  <para>
    Ayrıca bakınız: <function>is_callable</function>,
    <function>call_user_func</function>,
    <link linkend="language.variables.variable"> değişken değişkenleri</link>
    ve <function>function_exists</function>.
   </para>

   <sect2 role="changelog">
    &reftitle.changelog;
    <para>
     <informaltable>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>&Version;</entry>
         <entry>&Description;</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>7.0.0</entry>
         <entry>
          'SınıfAdı::yöntemAdı' bir değişken ismi olabilir.
         </entry>
        </row>
        <row>
         <entry>5.4.0</entry>
         <entry>
          Diziler de değişken işlev olabilir.
         </entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="functions.internal">
   <title>Yerleşik işlevler</title>

   <para>
    PHP standart olarak birçok işlev ve oluşum ile birlikte gelmektedir.
    Bunun yanında, özel PHP eklentilerinin derlenmesini gerektiren, aksi
    takdirde "tanımsız işlev" hatası üreten işlevler de mevcuttur. Örneğin,
    <function>imagecreatetruecolor</function> gibi <link linkend="ref.image"
    >resim</link> işlevlerini kullanabilmek için, PHP'yi
    <productname>GD</productname> desteğiyle derlemiş olmanız gerekir. Ya da,
    <function>mysql_connect</function> işlevini kullanabilmek için, PHP'nin
    <link linkend="ref.mysql">MySQL</link> desteği ile derlenmiş olması
    gerekmektedir. Bunların yanında, bütün PHP sürümlerine eklenen <link
    linkend="ref.strings">dizge</link> ve <link linkend="ref.var"
    >değişken</link> işlevleri gibi birçok çekirdek işlev de mevcuttur.
    <function>phpinfo</function> ya da
    <function>get_loaded_extensions</function> işlevlerine yapılacak bir
    çağrı ile PHP'ye hangi eklentilerin yüklenmiş olduğunu görebilirsiniz.
    Birçok uzantı öntanımlı olarak etkinleştirilmiş olup PHP Kılavuzunda bu
    eklentilerle ilgili geniş bilgi verilmiştir. PHP'yi nasıl yapılandırmanız
    gerektiğiyle ilgili bilgiyi <link linkend="configuration"
    >yapılandırma</link> ve <link linkend="install">kurulum</link> bölümleri
    ile eklerdeki özel bölümlerde bulabilirsiniz.
   </para>
   <para>
    Kılavuzun <link linkend="about.prototypes">işlev tanımı nasıl
    okunur</link> bölümünde bir işlev tanımının nasıl okunup anlaşılabileceği
    ile ilgili bilgiler bulunmaktadır. Bir işlevin bir değer mi döndürdüğü
    yoksa aktarılan değerlerle sadece işlem mi yaptığını anlamak önemlidir.
    Örneğin, <function>str_replace</function> değiştirilmiş dizgeyle
    dönerken, <function>usort</function> sadece kendisine aktarılan değer
    üzerinde çalışır. Ayrıca, her kılavuz sayfasında her işlevin
    değiştirgeleri, davranış değişiklikleri, başarı ya da başarısızlık
    durumunda döndürülen değerler ve kullanılabilirlik bilgileri
    bulunmaktadır. Bu önemli (ve sıklıkla algılanması güç) farklılıkların
    bilinmesi, doğru PHP kodunun yazılabilmesi için büyük önem taşımaktadır.
   </para>
   <para>
    Ayrıca bakınız: <function>function_exists</function>,
    <link linkend="funcref">İşlev Başvuru Kılavuzu</link>,
    <function>get_extension_funcs</function> ve
    <function>dl</function>.
   </para>
  </sect1>

  <sect1 xml:id="functions.anonymous">
   <title>Anonim işlevler</title>
   <simpara>
    Anonim işlevler isim belirtmeksizin oluşturulabilen işlevlerdir.
    Çoğunlukla <link linkend="language.types.callback">geriçağırım
    işlevi</link> olarak işlev değiştirgelerinde kullanılırsa da kullanımı
    bununla sınırlı değildir.
   </simpara>
   <simpara>
    Anonim işlevler 
    <link linkend="class.closure"><classname>Closure</classname></link> 
    sınıfı kullanılarak gerçeklenir.
   </simpara>

    <example>
     <title>- Anonim işlev örneği</title>
     <programlisting role="php">
<![CDATA[
<?php
echo preg_replace_callback('~-([a-z])~',
      function ($match) {
       return strtoupper($match[1]);
      },
      'hello-world');
// Çıktısı: helloWorld
?>
]]>
     </programlisting>
    </example>
   <para>
    Anonim işlevler birer değişken değeri olarak da bildirilebilir. Bu
    durumda PHP, işlevi özdevinimli olarak  sınıfının nesnel bir örneği
    haline getirir. Bir anonim işlev, bir değişkene sıradan bir deyim gibi,
    bir noktalı virgül ile biten bir işlev olarak atanabilir:
   </para>
    <example>
     <title>- Değişkene anonim işlev atama örneği</title>
     <programlisting role="php">
<![CDATA[
<?php
$greet = function($isim)
{
    printf("Merhaba %s\r\n", $isim);
};

$greet('Dünya');
$greet('PHP');
?>
]]>
     </programlisting>
    </example>
   <simpara>
    Anonim işlevler değişkenleri üst etki alanından miras alabilirler. Böyle
    değişkenler <literal>use</literal> dil oluşumuna aktarılmalıdır.
   </simpara>

   <example>
    <title>Değikenleri üst etki alanından miras almak</title>
    <programlisting role="php">
<![CDATA[
<?php
$message = 'hello';

// "use" olmaksızın
$example = function () {
    var_dump($message);
};
$example();

// $message miras alınır
$example = function () use ($message) {
    var_dump($message);
};
$example();

// Miras alınan deşkenin değeri işlevin tanımından gelir, çağrısından değil.
$message = 'world';
$example();

// message sıfırlanır
$message = 'hello';

// Gönderimle miras alma
$example = function () use (&$message) {
    var_dump($message);
};
$example();

// Üst etki alanında değişen değer
// işlev çağrısı içinde yansıtılır.
$message = 'world';
$example();

// Anonim işlevler sıradan değiştirgeleri de kabul edebilir
$example = function ($arg) use ($message) {
    var_dump($arg . ' ' . $message);
};
$example("hello");
?>
]]>
    </programlisting>
    &example.outputs.similar;
    <screen>
<![CDATA[
Notice: Undefined variable: message in /example.php on line 6
NULL
string(5) "hello"
string(5) "hello"
string(5) "hello"
string(5) "world"
string(11) "hello world"
]]>
    </screen>
   </example>

   <simpara>
    Üst etki alanından
    miras alınan değişkenler küresel değişkenler gibi ele alınmazlar.
    Küresel değişkenler, işlevin çalıştığı etki alanında tanımlı
    değişkenlerdir. Anonim işlevin üst etki alanı ise içinde bildirildiği
    işlevin etki alanıdır (Anonim işlevin bildirildiği etki alanı ile
    çağrıldığı etki alanı aynı olmak zorunda değildir). Aşağıdaki örneğe
    bakalım:
   </simpara>
    <example>
     <title>- Anonim işlevler ve etki alanı</title>
     <programlisting role="php">
<![CDATA[
<?php
// Ürünleri eklemek üzere bir Sepet oluşturalım.
// Eklenen ürünlerin toplam fiyatını döndürmek
// üzere bir geriçağırım işlevi kullanalım.
class Sepet
{
  const PRICE_BUTTER = 1.00;
  const PRICE_MILK = 3.00;
  const PRICE_EGGS = 6.95;

  protected $ürünler = Array();


  public static function ekle($ürün, $miktar)
  {
    $this->ürünler[$ürün] = $miktar;
  }

 public static function miktarıGetir($ürün)
 {
    return isset($this->ürünler[$ürün]) ? $this->ürünler[$ürün] : FALSE;

  }

  public function Toplam($kdv)
  {
      $toplam = 0.00;

      $işlev =
          function ($miktar, $ürün) use ($kdv, &$toplam)
          {
              $birimFiyat = constant(__CLASS__ . "::FiYAT_" .
                  strtoupper($ürün));
              $toplam += ($birimFiyat * $miktar) * ($kdv + 1.0);
          };

      array_walk($this->ürünler, $işlev);
      return round($toplam, 2);
  }
}

$sepetim = new Sepet;

// Sepete birşeyler ekleyelim
$sepetim->ekle('Peynir', 1);
$sepetim->ekle('Süt', 3);
$sepetim->ekle('Yumurta', 6);

// %5 KDV ile toplamı döndürelim
print $sepetim->Toplam(0.05) . "\n";
// sonuç: is 54.29
?>
]]>
     </programlisting>
   </example>
   
   <example>
    <title><literal>$this</literal>'in özdevinimli bağlanması</title>
    <programlisting role="php">
<![CDATA[
<?php

class Test
{
    public function testing()
    {
        return function() {
            var_dump($this);
        };
    }
}

$object = new Test;
$function = $object->testing();
$function();
    
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
object(Test)#1 (0) {
}
]]>
    </screen>
    &example.outputs.53;
    <screen>
<![CDATA[
Notice: Undefined variable: this in script.php on line 8
NULL]]>
    </screen>
   </example>

   <para>
    PHP 5.4.0 itibariyle, bir sınıf başka bir sınıfın içinde bildirildiğinde 
    <literal>$this</literal>'i işlevin etki alanı içinde kullanılabilir 
    kılarak özdevinimli olarak ona bağlanır. Bu özdevinimli bağlantı 
    istenmiyorsa bunun yerine <link linkend="functions.anonymous-functions.static">duruk 
    anonim işlevler</link> kullanılabilir.
   </para>

   <sect2 xml:id="functions.anonymous-functions.static">
    <title>Duruk anonim işlevler</title>
    <para>
     PHP 5.4 itibariyle, anonim işlevler duruk olarak bildirilebilmektedir.
     Böylece, geçerli sınıfın özdevinimli olarak bunlara bağlanamaması 
     sağlanabilir. Çalışma anında nesneler de özdevinimli olarak bunlara 
     bağlanamayacaktır.
    </para>
    <para>
     <example>
      <title>- Duruk anonim bir işlevin içinde <literal>$this</literal> 
        kullanmaya çalışmak</title>
      <programlisting role="php">
<![CDATA[
<?php

new class {
    function __construct()
    {
        (static function() {
            var_dump($this);
        })();
    }
};
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Notice: Undefined variable: this in %s on line %d
NULL
]]>
      </screen>
     </example>
    </para>

    <para>
     <example>
      <title>- Duruk anonim bir işleve bir nesne bağlamaya çalışmak</title>
      <programlisting role="php">
<![CDATA[
<?php

(static function() {
    // function body
})->call(new StdClass);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Warning: Cannot bind an instance to a static closure in /in/sLLS9 on line 5
]]>
      </screen>
     </example>
    </para>
   </sect2>

   <sect2 role="changelog">
    &reftitle.changelog;
    <para>
     <informaltable>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>&Version;</entry>
         <entry>&Description;</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>5.4.0</entry>
         <entry>
          Duruk olarak bildirilmek koşuluyla anonim işlevlerde 
          <varname>$this</varname> kullanılabilir.
         </entry>
        </row>
        <row>
         <entry>5.3.0</entry>
         <entry>
          Anonim işlevler kullanılabilir oldu.
         </entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
    </para>
   </sect2>

  <sect2 role="notes">
    &reftitle.notes;
    <note>
     <simpara>
     <function>func_num_args</function>, <function>func_get_args</function>
     ve <function>func_get_args</function> işlevini bir anonim işlev
     içinde kullanmak mümkündür.
    </simpara>
   </note>
  </sect2>
 </sect1>

</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
