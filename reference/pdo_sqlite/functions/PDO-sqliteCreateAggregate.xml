<?xml version='1.0' encoding='utf-8'?>
<!-- $Revision$ -->
<!-- EN-Revision: ddcceba83ec7cff59b6c46177d2d0fb2d5ad6a6b Maintainer: nilgun Status: ready -->
<refentry xml:id="function.pdo-sqlitecreateaggregate" xmlns="http://docbook.org/ns/docbook">
 <refnamediv>
  <refname>PDO::sqliteCreateAggregate</refname>
  <refpurpose>SQL deyimlerinde kullanmak üzere veri toplayıcı bir kullanıcı
  tanımlı işlevi kayda geçirir</refpurpose>
 </refnamediv>

 <refsect1 role="description">
  &reftitle.description;
  <classsynopsis>
   <ooclass><classname>PDO</classname></ooclass>
   <methodsynopsis>
    <type>bool</type><methodname>sqliteCreateAggregate</methodname>
    <methodparam><type>string</type><parameter>işlev_ismi</parameter></methodparam>
    <methodparam><type>callback</type><parameter>sekme_işlevi</parameter></methodparam>
    <methodparam><type>callback</type><parameter>son_işlev</parameter></methodparam>
    <methodparam choice="opt"><type>int</type><parameter>değş_sayısı</parameter></methodparam>
   </methodsynopsis>
  </classsynopsis>
  &warn.experimental.func;
  <para>
   Sorgudaki tüm satırlardan toplanan verilerden bir sonucu hesaplamak için
   kullanılacak bir işlevi kayda alması dışında
   <function>PDO::sqliteCreateFunction</function> işlevi gibidir.
  </para>
  <para>
   <function>PDO::sqliteCreateFunction</function> ile bu yöntem asarındaki
   asıl fark toplanan verilerin yönetimi ile ilgilidir.
  </para>
 </refsect1>

 <refsect1 role="parameters">
  &reftitle.parameters;
  <para>
   <variablelist>
    <varlistentry>
     <term><parameter>işlev_ismi</parameter></term>
     <listitem>
      <para>
       SQL deyimlerinde kullanılacak işlev ismi.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>sekme_işlevi</parameter></term>
     <listitem>
      <para>
       Sonuç kümesindeki her satır için çağrılacak geriçağırım işlevi. PHP
       işleviniz sonuçları toparlayıp bir toparlama bağlamına kaydetmelidir.
      </para>
      <para>
       Bu işlev şunların tanımlanmasını gerektirir:
       <methodsynopsis>
        <methodname><replaceable>sek</replaceable></methodname>
        <methodparam><type>mixed</type><parameter>bağlam</parameter></methodparam>
        <methodparam><type>int</type><parameter>satırnum</parameter></methodparam>
        <methodparam><type>mixed</type><parameter>değer1</parameter></methodparam>
        <methodparam choice="opt"><type>mixed</type><parameter>değer2</parameter></methodparam>
        <methodparam choice="opt"><type>mixed</type><parameter>..</parameter></methodparam>
       </methodsynopsis>
      </para>
      <para>
       <varname>bağlam</varname> ilk satır için &null; olacaktır; sonraki
       satırlarda ise önceki sekme işlevinden dönen değer olacaktır. Bunu
       toparlama durumunu sürdürmek için kullanmalısınız.
      </para>
      <para>
       <varname>satırnum</varname> geçerli satır numarasını içerecektir.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>son_işlev</parameter></term>
     <listitem>
      <para>
       Satırlardan adım adım toplanan veriden sonucu hesaplayacak geriçağırım
       işlevi. Bu işlev tüm veriler toparlama bağlamında toplandıktan sonra
       çağrılır ve hesap sonucunu döndürür. Dönüş türü SQLite tarafından
       bilinen veri türlerinden biri olmalıdır (<link
       linkend="language.types.intro">sayıl türler</link> gibi).
      </para>
      <para>
       Bu işlev şunların tanımlanmasını gerektirir:
       <methodsynopsis>
        <methodname><replaceable>son</replaceable></methodname>
        <methodparam><type>mixed</type><parameter>bağlam</parameter></methodparam>
        <methodparam><type>int</type><parameter>satırnum</parameter></methodparam>
       </methodsynopsis>
      </para>
      <para>
       <varname>bağlam</varname>, son sekme çağrısından dönen değeri içerir.
      </para>
      <para>
       <varname>satırnum</varname> toparlama işleminde kullanılan toplam satır
       sayısını içerir
      </para>
      <para>
       Bu işlevin dönüş değeri toparlama işleminin sonucu olarak kullanılır.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>değş_sayısı</parameter></term>
     <listitem>
      <para>
       Geriçağırım işlevi belli sayıda değiştirge gerektiriyorsa SQLite
       çözümleyiciye bir ipucu vermek için kullanılır.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsect1>

 <refsect1 role="returnvalues">
  &reftitle.returnvalues;
  <para>
   &return.success;
  </para>
 </refsect1>

 <refsect1 role="examples">
  &reftitle.examples;
  <para>
   <example>
    <title>- <code>azami_uzunluk</code> SQL işlevi örneği</title>
    <programlisting role="php">
<![CDATA[
<?php
$veri = array(
   'bir',
   'iki',
   'üç',
   'dört',
   'beş',
   'altı',
   'yedi',
   'sekiz',
   'dokuz',
   'on',
   );
$db = new PDO('sqlite::memory:');
$db->exec("CREATE TABLE dizgeler(a)");
$deyim = $db->prepare('INSERT INTO dizgeler VALUES (?)');
foreach ($veri as $dizge) {
    $deyim->execute(array($dizge));
}
$deyim = null;

function azami_uzunluk_sek(&$bağlam, $satırnum, $dizge)
{
    if (strlen($dizge) > $bağlam) {
        $bağlam = strlen($dizge);
    }
	return $bağlam;
}

function azami_uzunluk_son(&$bağlam, $satırnum)
{
    return $bağlam;
}

$db->sqliteCreateAggregate('azami_uzunluk',
        'azami_uzunluk_sek', 'azami_uzunluk_son');

var_dump($db->query('SELECT azami_uzunluk(a) from dizgeler')->fetchAll());

?>
]]>
    </programlisting>
   </example>
  </para>
  <para>
   Bu örnekte, bir tablonun sütunlarında bulunan dizgelerin en uzununun boyunu
   hesaplayan bir veri toparlama işlevi oluşturulmaktadır. Her satır için
   <literal>azami_uzunluk_sek</literal> işlevi çağrılmakta ve önceki
   <varname>$baglam</varname> değiştirgesindekinden daha uzun olan dizge daima
   <varname>$baglam</varname> değiştirgesindekiyle değiştirilmektedir.
   <varname>$baglam</varname> değiştirgesi herhangi bir PHP değişkeni gibi bir
   dizi veya nesne tutabilmelidir.
  </para>
  <para>
   Bütün satırlar işlemden geçirildikten sonra SQLite, sonucu döndürmek için
   <literal>azami_uzunluk_son</literal> işlevini çağırır. Burada
   <varname>$baglam</varname> değiştirgesindeki veriye dayalı her çeşit
   hesaplama yapabilirdik. Örneğimiz basit olsun çalıştırılan sorgudan elde
   edilen sonucu basit bir işleme sokup elde ettiğimiz bağlamı döndürmekle
   yetindik.
  </para>
  <tip>
   <para>
    Değerlerin kopyalarını bağlamda saklayıp sonra bunlar üzerinde işlem
    yapmanız önerilmez. Yoksa SQLite'ın sorguyu işlemek için çok fazla bellek
    kullanmasına sebep olursunuz. Her biri 32 baytlık bir dizge içeren bir
    milyon satır için ne kadar bellek gerektiğini bir düşünün.
   </para>
  </tip>
  <tip>
   <para>
    <function>PDO::sqliteCreateFunction</function> ve
    <function>PDO::sqliteCreateAggregate</function>  işlevlerini
    yerleşik SQLite SQL işlevlerini geçersiz kılmak için kullanabilirsiniz.
   </para>
  </tip>
  <note>
   <para>
    Bu yöntem, SQLite2 sürücüsü ile kullanılamaz; eski tarz SQLite arayüzünü
    kullanmalısınız.
   </para>
  </note>

 </refsect1>


 <refsect1 role="seealso">
  &reftitle.seealso;
  <para>
   <simplelist>
    <member><function>PDO::sqliteCreateFunction</function></member>
    <member><function>sqlite_create_function</function></member>
    <member><function>sqlite_create_aggregate</function></member>
   </simplelist>
  </para>
 </refsect1>

</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
